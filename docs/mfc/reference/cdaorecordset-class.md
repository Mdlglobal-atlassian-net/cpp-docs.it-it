---
title: CDaoRecordset (classe)
ms.date: 08/27/2018
f1_keywords:
- CDaoRecordset
- AFXDAO/CDaoRecordset
- AFXDAO/CDaoRecordset::CDaoRecordset
- AFXDAO/CDaoRecordset::AddNew
- AFXDAO/CDaoRecordset::CanAppend
- AFXDAO/CDaoRecordset::CanBookmark
- AFXDAO/CDaoRecordset::CancelUpdate
- AFXDAO/CDaoRecordset::CanRestart
- AFXDAO/CDaoRecordset::CanScroll
- AFXDAO/CDaoRecordset::CanTransact
- AFXDAO/CDaoRecordset::CanUpdate
- AFXDAO/CDaoRecordset::Close
- AFXDAO/CDaoRecordset::Delete
- AFXDAO/CDaoRecordset::DoFieldExchange
- AFXDAO/CDaoRecordset::Edit
- AFXDAO/CDaoRecordset::FillCache
- AFXDAO/CDaoRecordset::Find
- AFXDAO/CDaoRecordset::FindFirst
- AFXDAO/CDaoRecordset::FindLast
- AFXDAO/CDaoRecordset::FindNext
- AFXDAO/CDaoRecordset::FindPrev
- AFXDAO/CDaoRecordset::GetAbsolutePosition
- AFXDAO/CDaoRecordset::GetBookmark
- AFXDAO/CDaoRecordset::GetCacheSize
- AFXDAO/CDaoRecordset::GetCacheStart
- AFXDAO/CDaoRecordset::GetCurrentIndex
- AFXDAO/CDaoRecordset::GetDateCreated
- AFXDAO/CDaoRecordset::GetDateLastUpdated
- AFXDAO/CDaoRecordset::GetDefaultDBName
- AFXDAO/CDaoRecordset::GetDefaultSQL
- AFXDAO/CDaoRecordset::GetEditMode
- AFXDAO/CDaoRecordset::GetFieldCount
- AFXDAO/CDaoRecordset::GetFieldInfo
- AFXDAO/CDaoRecordset::GetFieldValue
- AFXDAO/CDaoRecordset::GetIndexCount
- AFXDAO/CDaoRecordset::GetIndexInfo
- AFXDAO/CDaoRecordset::GetLastModifiedBookmark
- AFXDAO/CDaoRecordset::GetLockingMode
- AFXDAO/CDaoRecordset::GetName
- AFXDAO/CDaoRecordset::GetParamValue
- AFXDAO/CDaoRecordset::GetPercentPosition
- AFXDAO/CDaoRecordset::GetRecordCount
- AFXDAO/CDaoRecordset::GetSQL
- AFXDAO/CDaoRecordset::GetType
- AFXDAO/CDaoRecordset::GetValidationRule
- AFXDAO/CDaoRecordset::GetValidationText
- AFXDAO/CDaoRecordset::IsBOF
- AFXDAO/CDaoRecordset::IsDeleted
- AFXDAO/CDaoRecordset::IsEOF
- AFXDAO/CDaoRecordset::IsFieldDirty
- AFXDAO/CDaoRecordset::IsFieldNull
- AFXDAO/CDaoRecordset::IsFieldNullable
- AFXDAO/CDaoRecordset::IsOpen
- AFXDAO/CDaoRecordset::Move
- AFXDAO/CDaoRecordset::MoveFirst
- AFXDAO/CDaoRecordset::MoveLast
- AFXDAO/CDaoRecordset::MoveNext
- AFXDAO/CDaoRecordset::MovePrev
- AFXDAO/CDaoRecordset::Open
- AFXDAO/CDaoRecordset::Requery
- AFXDAO/CDaoRecordset::Seek
- AFXDAO/CDaoRecordset::SetAbsolutePosition
- AFXDAO/CDaoRecordset::SetBookmark
- AFXDAO/CDaoRecordset::SetCacheSize
- AFXDAO/CDaoRecordset::SetCacheStart
- AFXDAO/CDaoRecordset::SetCurrentIndex
- AFXDAO/CDaoRecordset::SetFieldDirty
- AFXDAO/CDaoRecordset::SetFieldNull
- AFXDAO/CDaoRecordset::SetFieldValue
- AFXDAO/CDaoRecordset::SetFieldValueNull
- AFXDAO/CDaoRecordset::SetLockingMode
- AFXDAO/CDaoRecordset::SetParamValue
- AFXDAO/CDaoRecordset::SetParamValueNull
- AFXDAO/CDaoRecordset::SetPercentPosition
- AFXDAO/CDaoRecordset::Update
- AFXDAO/CDaoRecordset::m_bCheckCacheForDirtyFields
- AFXDAO/CDaoRecordset::m_nFields
- AFXDAO/CDaoRecordset::m_nParams
- AFXDAO/CDaoRecordset::m_pDAORecordset
- AFXDAO/CDaoRecordset::m_pDatabase
- AFXDAO/CDaoRecordset::m_strFilter
- AFXDAO/CDaoRecordset::m_strSort
helpviewer_keywords:
- CDaoRecordset [MFC], CDaoRecordset
- CDaoRecordset [MFC], AddNew
- CDaoRecordset [MFC], CanAppend
- CDaoRecordset [MFC], CanBookmark
- CDaoRecordset [MFC], CancelUpdate
- CDaoRecordset [MFC], CanRestart
- CDaoRecordset [MFC], CanScroll
- CDaoRecordset [MFC], CanTransact
- CDaoRecordset [MFC], CanUpdate
- CDaoRecordset [MFC], Close
- CDaoRecordset [MFC], Delete
- CDaoRecordset [MFC], DoFieldExchange
- CDaoRecordset [MFC], Edit
- CDaoRecordset [MFC], FillCache
- CDaoRecordset [MFC], Find
- CDaoRecordset [MFC], FindFirst
- CDaoRecordset [MFC], FindLast
- CDaoRecordset [MFC], FindNext
- CDaoRecordset [MFC], FindPrev
- CDaoRecordset [MFC], GetAbsolutePosition
- CDaoRecordset [MFC], GetBookmark
- CDaoRecordset [MFC], GetCacheSize
- CDaoRecordset [MFC], GetCacheStart
- CDaoRecordset [MFC], GetCurrentIndex
- CDaoRecordset [MFC], GetDateCreated
- CDaoRecordset [MFC], GetDateLastUpdated
- CDaoRecordset [MFC], GetDefaultDBName
- CDaoRecordset [MFC], GetDefaultSQL
- CDaoRecordset [MFC], GetEditMode
- CDaoRecordset [MFC], GetFieldCount
- CDaoRecordset [MFC], GetFieldInfo
- CDaoRecordset [MFC], GetFieldValue
- CDaoRecordset [MFC], GetIndexCount
- CDaoRecordset [MFC], GetIndexInfo
- CDaoRecordset [MFC], GetLastModifiedBookmark
- CDaoRecordset [MFC], GetLockingMode
- CDaoRecordset [MFC], GetName
- CDaoRecordset [MFC], GetParamValue
- CDaoRecordset [MFC], GetPercentPosition
- CDaoRecordset [MFC], GetRecordCount
- CDaoRecordset [MFC], GetSQL
- CDaoRecordset [MFC], GetType
- CDaoRecordset [MFC], GetValidationRule
- CDaoRecordset [MFC], GetValidationText
- CDaoRecordset [MFC], IsBOF
- CDaoRecordset [MFC], IsDeleted
- CDaoRecordset [MFC], IsEOF
- CDaoRecordset [MFC], IsFieldDirty
- CDaoRecordset [MFC], IsFieldNull
- CDaoRecordset [MFC], IsFieldNullable
- CDaoRecordset [MFC], IsOpen
- CDaoRecordset [MFC], Move
- CDaoRecordset [MFC], MoveFirst
- CDaoRecordset [MFC], MoveLast
- CDaoRecordset [MFC], MoveNext
- CDaoRecordset [MFC], MovePrev
- CDaoRecordset [MFC], Open
- CDaoRecordset [MFC], Requery
- CDaoRecordset [MFC], Seek
- CDaoRecordset [MFC], SetAbsolutePosition
- CDaoRecordset [MFC], SetBookmark
- CDaoRecordset [MFC], SetCacheSize
- CDaoRecordset [MFC], SetCacheStart
- CDaoRecordset [MFC], SetCurrentIndex
- CDaoRecordset [MFC], SetFieldDirty
- CDaoRecordset [MFC], SetFieldNull
- CDaoRecordset [MFC], SetFieldValue
- CDaoRecordset [MFC], SetFieldValueNull
- CDaoRecordset [MFC], SetLockingMode
- CDaoRecordset [MFC], SetParamValue
- CDaoRecordset [MFC], SetParamValueNull
- CDaoRecordset [MFC], SetPercentPosition
- CDaoRecordset [MFC], Update
- CDaoRecordset [MFC], m_bCheckCacheForDirtyFields
- CDaoRecordset [MFC], m_nFields
- CDaoRecordset [MFC], m_nParams
- CDaoRecordset [MFC], m_pDAORecordset
- CDaoRecordset [MFC], m_pDatabase
- CDaoRecordset [MFC], m_strFilter
- CDaoRecordset [MFC], m_strSort
ms.assetid: 2322067f-1027-4662-a5d7-aa2fc7488630
ms.openlocfilehash: 5b4b2919405696c748ce01217ac82afeac316de2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/14/2020
ms.locfileid: "81377156"
---
# <a name="cdaorecordset-class"></a>CDaoRecordset (classe)

Rappresenta un set di record selezionati da un'origine dati.

## <a name="syntax"></a>Sintassi

```
class CDaoRecordset : public CObject
```

## <a name="members"></a>Membri

### <a name="public-constructors"></a>Costruttori pubblici

|Nome|Descrizione|
|----------|-----------------|
|[CDaoRecordset::CDaoRecordset](#cdaorecordset)|Costruisce un oggetto `CDaoRecordset`.|

### <a name="public-methods"></a>Metodi pubblici

|Nome|Descrizione|
|----------|-----------------|
|[CDaoRecordset::AddNew](#addnew)|Prepara l'aggiunta di un nuovo record. Chiamare [Update](#update) per completare l'aggiunta.|
|[CDaoRecordset::CanAppend](#canappend)|Restituisce diverso da zero se è possibile aggiungere nuovi record al recordset tramite la funzione membro [AddNew.](#addnew)|
|[CDaoRecordset::CanBookmark](#canbookmark)|Restituisce un valore diverso da zero se il recordset supporta i segnalibri.|
|[CDaoRecordset::CancelUpdate](#cancelupdate)|Annulla tutti gli aggiornamenti in sospeso a causa di un'operazione [di modifica](#edit) o [AggiuntaNuovo.](#addnew)|
|[CDaoRecordset::CanRestart](#canrestart)|Restituisce diverso da zero se è possibile chiamare [Requery](#requery) per eseguire nuovamente la query del recordset.|
|[CDaoRecordset::CanScroll](#canscroll)|Restituisce diverso da zero se è possibile scorrere i record.|
|[CDaoRecordset::CanTransact](#cantransact)|Restituisce un valore diverso da zero se l'origine dati supporta le transazioni.|
|[CDaoRecordset::CanUpdate](#canupdate)|Restituisce un valore diverso da zero se il recordset può essere aggiornato (è possibile aggiungere, aggiornare o eliminare record).|
|[CDaoRecordset::Chiudi](#close)|Chiude il recordset.|
|[CDaoRecordset::Delete](#delete)|Elimina il record corrente dal recordset. È necessario scorrere in modo esplicito fino a un altro record dopo l'eliminazione.|
|[CDaoRecordset::DoFieldExchange](#dofieldexchange)|Chiamato per lo scambio di dati (in entrambe le direzioni) tra i membri dati di campo del recordset e il record corrispondente nell'origine dati. Implementa lo scambio di campi di record DAO (DFX).|
|[CDaoRecordset::Modifica](#edit)|Prepara le modifiche apportate al record corrente. Chiamata `Update` per completare la modifica.|
|[CDaoRecordset::FillCache](#fillcache)|Riempie tutta o una parte di una cache locale per un oggetto recordset che contiene i dati da un'origine dati ODBC.|
|[CDaoRecordset::Find](#find)|Individua la prima, successiva, precedente o ultima posizione di una determinata stringa in un recordset di tipo dynaset che soddisfa i criteri specificati e rende tale record il record corrente.|
|[CDaoRecordset::FindFirst](#findfirst)|Individua il primo record in un recordset di tipo dynaset o snapshot che soddisfa i criteri specificati e rende tale record il record corrente.|
|[CDaoRecordset::FindLast](#findlast)|Individua l'ultimo record in un recordset di tipo dynaset o snapshot che soddisfa i criteri specificati e rende tale record il record corrente.|
|[CDaoRecordset::FindNext](#findnext)|Individua il record successivo in un recordset di tipo dynaset o snapshot che soddisfa i criteri specificati e rende tale record il record corrente.|
|[CDaoRecordset::FindPrev](#findprev)|Individua il record precedente in un recordset di tipo dynaset o snapshot che soddisfa i criteri specificati e rende tale record il record corrente.|
|[CDaoRecordset::GetAbsolutePosition](#getabsoluteposition)|Restituisce il numero di record del record corrente di un oggetto recordset.|
|[CDaoRecordset::GetBookmark](#getbookmark)|Restituisce un valore che rappresenta il segnalibro in un record.|
|[CDaoRecordset::GetCacheSize](#getcachesize)|Restituisce un valore che specifica il numero di record in un recordset di tipo dynaset contenente dati da memorizzare localmente nella cache da un'origine dati ODBC.|
|[CDaoRecordset::GetCacheStart](#getcachestart)|Restituisce un valore che specifica il segnalibro del primo record del recordset da memorizzare nella cache.|
|[CDaoRecordset::GetCurrentIndex](#getcurrentindex)|Restituisce `CString` un contenente il nome dell'indice utilizzato più `CDaoRecordset`di recente in un indicizzato di tipo tabella .|
|[CDaoRecordset::GetDateCreated](#getdatecreated)|Restituisce la data e l'ora di creazione della tabella di base sottostante è stato creato un `CDaoRecordset` oggetto|
|[CDaoRecordset::GetDateLastUpdated](#getdatelastupdated)|Restituisce la data e l'ora della modifica più recente `CDaoRecordset` apportata alla progettazione di una tabella di base all'altro sottostante un oggetto.|
|[CDaoRecordset::GetDefaultDBName](#getdefaultdbname)|Restituisce il nome dell'origine dati predefinita.|
|[CDaoRecordset::GetDefaultSQL](#getdefaultsql)|Chiamato per ottenere la stringa SQL predefinita da eseguire.|
|[CDaoRecordset::GetEditMode](#geteditmode)|Restituisce un valore che indica lo stato di modifica del record corrente.|
|[CDaoRecordset::GetFieldCount](#getfieldcount)|Restituisce un valore che rappresenta il numero di campi in un recordset.|
|[CDaoRecordset::GetFieldInfo](#getfieldinfo)|Restituisce tipi specifici di informazioni sui campi del recordset.|
|[CDaoRecordset::GetFieldValue](#getfieldvalue)|Restituisce il valore di un campo in un recordset.|
|[CDaoRecordset::GetIndexCount](#getindexcount)|Recupera il numero di indici in una tabella sottostante un recordset.|
|[CDaoRecordset::GetIndexInfo](#getindexinfo)|Restituisce vari tipi di informazioni su un indice.|
|[CDaoRecordset::GetLastModifiedBookmark](#getlastmodifiedbookmark)|Utilizzato per determinare il record aggiunto o aggiornato più di recente.|
|[CDaoRecordset::GetLockingMode](#getlockingmode)|Restituisce un valore che indica il tipo di blocco attivo durante la modifica.|
|[CDaoRecordset::GetName](#getname)|Restituisce `CString` un contenente il nome del recordset.|
|[CDaoRecordset::GetParamValue](#getparamvalue)|Recupera il valore corrente del parametro specificato archiviato nell'oggetto DAOParameter sottostante.|
|[CDaoRecordset::GetPercentPosition](#getpercentposition)|Restituisce la posizione del record corrente come percentuale del numero totale di record.|
|[CDaoRecordset::GetRecordCount](#getrecordcount)|Restituisce il numero di record a cui si accede in un oggetto recordset.|
|[CDaoRecordset::GetSQL](#getsql)|Ottiene la stringa SQL utilizzata per selezionare i record per il recordset.|
|[CDaoRecordset::GetType](#gettype)|Chiamato per determinare il tipo di un recordset: tipo di tabella, tipo dynaset o tipo snapshot.|
|[CDaoRecordset::GetValidationRule](#getvalidationrule)|Restituisce `CString` un oggetto contenente il valore che convalida i dati quando vengono immessi in un campo.|
|[CDaoRecordset::GetValidationText](#getvalidationtext)|Recupera il testo visualizzato quando una regola di convalida non viene soddisfatta.|
|[CDaoRecordset::IsBOF](#isbof)|Restituisce un valore diverso da zero se il recordset è stato posizionato prima del primo record. Non è presente nessun record corrente.|
|[CDaoRecordset::IsDeleted](#isdeleted)|Restituisce un valore diverso da zero se il recordset è posizionato su un record eliminato.|
|[CDaoRecordset::IsEOF](#iseof)|Restituisce un valore diverso da zero se il recordset è stato posizionato dopo l'ultimo record. Non è presente nessun record corrente.|
|[CDaoRecordset::IsFieldDirty](#isfielddirty)|Restituisce diverso da zero se il campo specificato nel record corrente è stato modificato.|
|[CDaoRecordset::IsFieldNull](#isfieldnull)|Restituisce diverso da zero se il campo specificato nel record corrente è Null (senza alcun valore).|
|[CDaoRecordset::IsFieldNullable](#isfieldnullable)|Restituisce diverso da zero se il campo specificato nel record corrente può essere impostato su Null (senza alcun valore).|
|[CDaoRecordset::IsOpen](#isopen)|Restituisce diverso da zero se [Open](#open) è stato chiamato in precedenza.|
|[CDaoRecordset::Sposta](#move)|Posiziona il recordset a un numero specificato di record dal record corrente in entrambe le direzioni.|
|[CDaoRecordset::MoveFirst](#movefirst)|Posiziona il record corrente sul primo record del recordset.|
|[CDaoRecordset::MoveLast](#movelast)|Posiziona il record corrente sull'ultimo record del recordset.|
|[CDaoRecordset::MoveNext](#movenext)|Posiziona il record corrente sul record successivo nel recordset.|
|[CDaoRecordset::MovePrev](#moveprev)|Posiziona il record corrente del record precedente nel recordset.|
|[CDaoRecordset::Open](#open)|Crea un nuovo recordset da una tabella, un dynaset o uno snapshot.|
|[CDaoRecordset::Requery](#requery)|Esegue nuovamente la query del recordset per aggiornare i record selezionati.|
|[CDaoRecordset::Seek](#seek)|Individua il record in un oggetto recordset di tipo tabella indicizzato che soddisfa i criteri specificati per l'indice corrente e rende tale record il record corrente.|
|[CDaoRecordset::SetAbsolutePosition](#setabsoluteposition)|Imposta il numero di record del record corrente di un oggetto recordset.|
|[CDaoRecordset::SetBookmark](#setbookmark)|Posiziona il recordset su un record contenente il segnalibro specificato.|
|[CDaoRecordset::SetCacheSize](#setcachesize)|Imposta un valore che specifica il numero di record in un recordset di tipo dynaset contenente dati da memorizzare localmente nella cache da un'origine dati ODBC.|
|[CDaoRecordset::SetCacheStart](#setcachestart)|Imposta un valore che specifica il segnalibro del primo record del recordset da memorizzare nella cache.|
|[CDaoRecordset::SetCurrentIndex](#setcurrentindex)|Chiamato per impostare un indice in un recordset di tipo tabella.|
|[CDaoRecordset::SetFieldDirty](#setfielddirty)|Contrassegna il campo specificato nel record corrente come modificato.|
|[CDaoRecordset::SetFieldNull](#setfieldnull)|Imposta il valore del campo specificato nel record corrente su Null (senza alcun valore).|
|[CDaoRecordset::SetFieldValue](#setfieldvalue)|Imposta il valore di un campo in un recordset.|
|[CDaoRecordset::SetFieldValueNull](#setfieldvaluenull)|Imposta il valore di un campo in un recordset su Null. (non avendo alcun valore).|
|[CDaoRecordset::SetLockingMode](#setlockingmode)|Imposta un valore che indica il tipo di blocco da mettere in vigore durante la modifica.|
|[CDaoRecordset::SetParamValue](#setparamvalue)|Imposta il valore corrente del parametro specificato archiviato nell'oggetto DAOParameter sottostante|
|[CDaoRecordset::SetParamValueNull](#setparamvaluenull)|Imposta il valore corrente del parametro specificato su Null (senza alcun valore).|
|[CDaoRecordset::SetPercentPosition](#setpercentposition)|Imposta la posizione del record corrente in una posizione corrispondente a una percentuale del numero totale di record in un recordset.|
|[CDaoRecordset::Aggiornamento](#update)|Completa un'operazione `AddNew` o `Edit` salvando i dati nuovi o modificati nell'origine dati.|

### <a name="public-data-members"></a>Membri dati pubblici

|Nome|Descrizione|
|----------|-----------------|
|[CDaoRecordset::m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields)|Contiene un flag che indica se i campi vengono contrassegnati automaticamente come modificati.|
|[CDaoRecordset::m_nFields](#m_nfields)|Contiene il numero di membri dati di campo nella classe recordset e il numero di colonne selezionate dal recordset dall'origine dati.|
|[CDaoRecordset::m_nParams](#m_nparams)|Contiene il numero di membri dati di parametro nella classe recordset, ovvero il numero di parametri passati con la query del recordset.|
|[CDaoRecordset::m_pDAORecordset](#m_pdaorecordset)|Puntatore all'interfaccia DAO sottostante l'oggetto recordset.|
|[CDaoRecordset::m_pDatabase](#m_pdatabase)|Database di origine per questo set di risultati. Contiene un puntatore a un oggetto [CDaoDatabase.](../../mfc/reference/cdaodatabase-class.md)|
|[CDaoRecordset::m_strFilter](#m_strfilter)|Contiene una stringa utilizzata per costruire un'istruzione SQL **WHERE.**|
|[CDaoRecordset::m_strSort](#m_strsort)|Contiene una stringa utilizzata per costruire un'istruzione SQL **ORDER BY.**|

## <a name="remarks"></a>Osservazioni

Gli oggetti noti `CDaoRecordset` come "recordset" sono disponibili nei tre formati seguenti:

- I recordset di tipo tabella rappresentano una tabella di base che è possibile utilizzare per esaminare, aggiungere, modificare o eliminare record da una singola tabella di database.

- I recordset di tipo Dynaset sono il risultato di una query che può avere record aggiornabili. Questi recordset sono un set di record che è possibile utilizzare per esaminare, aggiungere, modificare o eliminare record da una tabella o tabelle di database sottostante. I recordset di tipo Dynaset possono contenere campi di una o più tabelle di un database.

- I recordset di tipo snapshot sono una copia statica di un set di record che è possibile utilizzare per trovare dati o generare report. Questi recordset possono contenere campi di una o più tabelle di un database, ma non possono essere aggiornati.

Ogni forma di recordset rappresenta un set di record fissi al momento dell'apertura del recordset. Quando si scorre su un record in un recordset di tipo tabella o in un recordset di tipo dynaset, vengono rispecchiate le modifiche apportate al record dopo l'apertura del recordset, da altri utenti o da altri recordset nell'applicazione. Non è possibile aggiornare un recordset di tipo snapshot. È possibile `CDaoRecordset` utilizzare direttamente o derivare `CDaoRecordset`una classe recordset specifica dell'applicazione da . Sarà quindi possibile:

- Scorrere i record.

- Impostare un indice e cercare rapidamente i record utilizzando [Seek](#seek) (solo recordset di tipo tabella).

- Trovare i record in base a un\<confronto tra stringhe: "<", " s "" , """ , ">" o ">" (recordset di tipo dynaset e snapshot).

- Aggiornare i record e specificare una modalità di blocco (ad eccezione dei recordset di tipo snapshot).

- Filtrare il recordset per vincolare i record selezionati tra quelli disponibili nell'origine dati.

- Ordinare il recordset.

- Parametrizzare il recordset per personalizzarne la selezione con informazioni non note fino alla fase di esecuzione.

Class `CDaoRecordset` fornisce un'interfaccia simile `CRecordset`a quella della classe . La differenza principale `CDaoRecordset` è che la classe accede ai dati tramite un DAO (Data Access Object) basato su OLE. La `CRecordset` classe accede al sistema DBMS tramite ODBC (Open Database Connectivity) e un driver ODBC per tale DBMS.

> [!NOTE]
> Le classi di database DAO sono distinte dalle classi di database MFC basate su ODBC (Open Database Connectivity). Tutti i nomi delle classi di database DAO hanno il prefisso "CDao". È comunque possibile accedere alle origini dati ODBC con le classi DAO; le classi DAO offrono in genere funzionalità superiori perché sono specifiche del modulo di gestione di database Microsoft Jet.

È possibile `CDaoRecordset` utilizzare direttamente o `CDaoRecordset`derivare una classe da . Per utilizzare una classe recordset in entrambi i casi, aprire un database `CDaoDatabase` e costruire un oggetto recordset, passando all'oggetto un puntatore all'oggetto del costruttore. È inoltre possibile `CDaoRecordset` costruire un oggetto `CDaoDatabase` e consentire a MFC di creare automaticamente un oggetto temporaneo. Chiamare quindi la funzione membro [Open](#open) del recordset, specificando se l'oggetto è un recordset di tipo tabella, un recordset di tipo dynaset o un recordset di tipo snapshot. La `Open` chiamata seleziona i dati dal database e recupera il primo record.

Utilizzare le funzioni membro e i membri dati dell'oggetto per scorrere i record e operare su di essi. Le operazioni disponibili dipendono dal fatto che l'oggetto sia un recordset di tipo tabella, un recordset di tipo dynaset o un recordset di tipo snapshot e che sia aggiornabile o di sola lettura, a seconda della funzionalità del database o dell'origine dati ODBC (Open Database Connectivity). Per aggiornare i record che potrebbero `Open` essere stati modificati o aggiunti dopo la chiamata, chiamare la funzione membro [Requery](#requery) dell'oggetto. Chiamare la funzione `Close` membro dell'oggetto ed eliminare l'oggetto al termine.

`CDaoRecordset`utilizza lo scambio di campi di record DAO (DFX) per supportare `CDaoRecordset` la `CDaoRecordset`lettura e l'aggiornamento dei campi di record tramite i membri indipendenti dai tipi della classe o della classe derivata da Un Po. È inoltre possibile implementare l'associazione dinamica delle colonne in un database senza utilizzare il meccanismo DFX utilizzando [GetFieldValue](#getfieldvalue) e [SetFieldValue](#setfieldvalue).

Per informazioni correlate, vedere l'argomento "Oggetto Recordset" nella Guida in linea di DAO.

## <a name="inheritance-hierarchy"></a>Gerarchia di ereditarietà

[CObject](../../mfc/reference/cobject-class.md)

`CDaoRecordset`

## <a name="requirements"></a>Requisiti

**Intestazione:** afxdao.h

## <a name="cdaorecordsetaddnew"></a><a name="addnew"></a>CDaoRecordset::AddNew

Chiamare questa funzione membro per aggiungere un nuovo record a un recordset di tipo tabella o dynaset.

```
virtual void AddNew();
```

### <a name="remarks"></a>Osservazioni

I campi del record sono inizialmente Null. (Nella terminologia del database, Null significa "non avere alcun valore" e non è uguale a NULL in C . Per completare l'operazione, è necessario chiamare la funzione membro [Update.](#update) `Update`salva le modifiche apportate all'origine dati.

> [!CAUTION]
> Se si modifica un record e quindi `Update`si scorre verso un altro record senza chiamare , le modifiche andranno perse senza alcun avviso.

Se si aggiunge un record a un recordset di tipo dynaset chiamando [AddNew](#addnew), il record sarà visibile `CDaoRecordset` nel recordset e incluso nella tabella sottostante in cui diventa visibile a tutti i nuovi oggetti.

La posizione del nuovo record dipende dal tipo di recordset:

- In un recordset di tipo dynaset, non è garantito il nuovo record. Questo comportamento è cambiato con Microsoft Jet 3.0 per motivi di prestazioni e concorrenza. Se l'obiettivo è rendere il record appena aggiunto come record corrente, ottenere il segnalibro dell'ultimo record modificato e passare a tale segnalibro:

[!code-cpp[NVC_MFCDatabase#1](../../mfc/codesnippet/cpp/cdaorecordset-class_1.cpp)]

- In un recordset di tipo tabella per il quale è stato specificato un indice, i record vengono restituiti nella posizione corretta nell'ordinamento. Se non è stato specificato alcun indice, vengono restituiti nuovi record alla fine del recordset.

Il record corrente prima `AddNew` dell'uso rimane aggiornato. Se si desidera rendere corrente il nuovo record e il recordset supporta i segnalibri, chiamare [SetBookmark](#setbookmark) sul segnalibro identificato dall'impostazione della proprietà LastModified dell'oggetto recordset DAO sottostante. Questa operazione è utile per determinare il valore per i campi contatore (incremento automatico) in un record aggiunto. Per ulteriori informazioni, vedere [GetLastModifiedBookmark](#getlastmodifiedbookmark).

Se il database supporta le transazioni, è possibile rendere la `AddNew` chiamata parte di una transazione. Per ulteriori informazioni sulle transazioni, vedere la classe [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md). Si noti che è necessario chiamare [CDaoWorkspace::BeginTrans](../../mfc/reference/cdaoworkspace-class.md#begintrans) prima di chiamare `AddNew`.

Non è consentito chiamare `AddNew` un recordset la cui funzione membro [Open](#open) non è stata chiamata. Viene `CDaoException` generata un'eccezione se si chiama `AddNew` un recordset che non può essere aggiunto. È possibile determinare se il recordset è aggiornabile chiamando [CanAppend](#canappend).

Il framework contrassegna i membri dati di campo modificati per garantire che verranno scritti nel record nell'origine dati dal meccanismo DFX (Record Field Exchange) DAO. La modifica del valore di un campo in genere imposta il campo dirty automaticamente, pertanto raramente sarà necessario chiamare [SetFieldDirty](#setfielddirty) manualmente, ma a volte potrebbe essere necessario assicurarsi che le colonne vengano aggiornate o inserite in modo esplicito indipendentemente dal valore nel membro dati del campo. Il meccanismo DFX utilizza anche l'utilizzo di **PSEUDO NULL**. Per ulteriori informazioni, vedere [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Se il meccanismo del doppio buffer non viene utilizzato, la modifica del valore del campo non imposta automaticamente il campo come dirty. In questo caso, sarà necessario impostare in modo esplicito il campo dirty. Il flag contenuto in [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controlla questo controllo automatico dei campi.

> [!NOTE]
> Se i record sono a doppio buffer, ovvero è `CancelUpdate` abilitato il controllo automatico dei `AddNew` campi, la chiamata ripristinerà le variabili membro ai valori che avevano prima o `Edit` che erano chiamate.

Per informazioni correlate, vedere gli argomenti "AddNew Method", "CancelUpdate Method", "LastModified Property" e "EditMode Property" nella Guida di DAO.

## <a name="cdaorecordsetcanappend"></a><a name="canappend"></a>CDaoRecordset::CanAppend

Chiamare questa funzione membro per determinare se il recordset aperto in precedenza consente di aggiungere nuovi record chiamando il [AddNew](#addnew) funzione membro.

```
BOOL CanAppend() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il recordset consente l'aggiunta di nuovi record; in caso contrario 0. `CanAppend`restituirà 0 se il recordset è stato aperto in sola lettura.

### <a name="remarks"></a>Osservazioni

Per informazioni correlate, vedere l'argomento "Metodo Append" nella Guida in linea di DAO.

## <a name="cdaorecordsetcanbookmark"></a><a name="canbookmark"></a>CDaoRecordset::CanBookmark

Chiamare questa funzione membro per determinare se il recordset aperto in precedenza consente di contrassegnare singolarmente i record utilizzando i segnalibri.

```
BOOL CanBookmark();
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il recordset supporta i segnalibri, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Se si utilizzano recordset basati interamente su tabelle del motore di database Microsoft Jet, è possibile utilizzare segnalibri, ad eccezione dei recordset di tipo snapshot contrassegnati come recordset a scorrimento forward-only. Altri prodotti di database (origini dati ODBC esterne) potrebbero non supportare i segnalibri.

Per informazioni correlate, vedere l'argomento "Proprietà Bookmarkable" nella Guida in linea di DAO.

## <a name="cdaorecordsetcancelupdate"></a><a name="cancelupdate"></a>CDaoRecordset::CancelUpdate

La `CancelUpdate` funzione membro annulla tutti gli aggiornamenti in sospeso a causa di [un'operazione Edit](#edit) o [AddNew.](#addnew)

```
virtual void CancelUpdate();
```

### <a name="remarks"></a>Osservazioni

Ad `Edit` esempio, se un'applicazione chiama la funzione membro o `AddNew` e non ha chiamato [Update](#update), `CancelUpdate` annulla le modifiche apportate dopo `Edit` o `AddNew` è stato chiamato.

> [!NOTE]
> Se i record sono a doppio buffer, ovvero è `CancelUpdate` abilitato il controllo automatico dei `AddNew` campi, la chiamata ripristinerà le variabili membro ai valori che avevano prima o `Edit` che erano chiamate.

Se non `Edit` è `AddNew` presente `CancelUpdate` o l'operazione in sospeso, fa sì che MFC generare un'eccezione. Chiamare il [GetEditMode](#geteditmode) funzione membro per determinare se è presente un'operazione in sospeso che può essere annullata.

Per informazioni correlate, vedere l'argomento "Metodo CancelUpdate" nella Guida in linea di DAO.

## <a name="cdaorecordsetcanrestart"></a><a name="canrestart"></a>CDaoRecordset::CanRestart

Chiamare questa funzione membro per determinare se il recordset consente il riavvio della query (per aggiornare i record) chiamando la `Requery` funzione membro.

```
BOOL CanRestart();
```

### <a name="return-value"></a>Valore restituito

Diverso da `Requery` zero se può essere chiamato per eseguire nuovamente la query del recordset, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

I recordset di tipo `Requery`tabella non supportano .

Se `Requery` non è supportato, chiamare [Chiudi,](#close) quindi [Apri](#open) per aggiornare i dati. È possibile `Requery` chiamare per aggiornare la query del parametro sottostante di un oggetto recordset dopo la modifica dei valori dei parametri.

Per informazioni correlate, vedere l'argomento "Proprietà riavviabile" nella Guida in linea di DAO.

## <a name="cdaorecordsetcanscroll"></a><a name="canscroll"></a>CDaoRecordset::CanScroll

Chiamare questa funzione membro per determinare se il recordset consente lo scorrimento.

```
BOOL CanScroll() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se è possibile scorrere i record, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Se si [Open](#open) chiama `dbForwardOnly`Open con , il recordset può scorrere solo in avanti.

Per informazioni correlate, vedere l'argomento "Posizionamento del puntatore di record corrente con DAO" nella Guida in linea di DAO.

## <a name="cdaorecordsetcantransact"></a><a name="cantransact"></a>CDaoRecordset::CanTransact

Chiamare questa funzione membro per determinare se il recordset consente le transazioni.

```
BOOL CanTransact();
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se l'origine dati sottostante supporta le transazioni, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Per informazioni correlate, vedere l'argomento "Proprietà Transactions" nella Guida in linea di DAO.

## <a name="cdaorecordsetcanupdate"></a><a name="canupdate"></a>CDaoRecordset::CanUpdate

Chiamare questa funzione membro per determinare se il recordset può essere aggiornato.

```
BOOL CanUpdate() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il recordset può essere aggiornato (aggiungere, aggiornare ed eliminare record), in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Un recordset può essere di sola lettura se l'origine `dbReadOnly` dati sottostante è di sola lettura o se è stato specificato per *nOptions* quando si chiama [Open](#open) per il recordset.

Per informazioni correlate, vedere gli argomenti "AddNew Method", "Edit Method", "Delete Method", "Update Method" e "Updatable Property" nella Guida in linea di DAO.

## <a name="cdaorecordsetcdaorecordset"></a><a name="cdaorecordset"></a>CDaoRecordset::CDaoRecordset

Costruisce un oggetto `CDaoRecordset`.

```
CDaoRecordset(CDaoDatabase* pDatabase = NULL);
```

### <a name="parameters"></a>Parametri

*pDatabase*<br/>
Contiene un puntatore a un oggetto [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md) o il valore NULL. Se non NULL `CDaoDatabase` e `Open` la funzione membro dell'oggetto non è stata chiamata per connetterla all'origine dati, il recordset tenta di aprirlo automaticamente durante la propria chiamata [Open.](#open) Se si passa `CDaoDatabase` NULL, un oggetto viene costruito e connesso automaticamente utilizzando le `CDaoRecordset`informazioni sull'origine dati specificate se la classe recordset è stata derivata da .

### <a name="remarks"></a>Osservazioni

È possibile `CDaoRecordset` utilizzare direttamente o derivare `CDaoRecordset`una classe specifica dell'applicazione da . È possibile utilizzare ClassWizard per derivare le classi recordset.

> [!NOTE]
> Se si `CDaoRecordset` deriva una classe, la classe derivata deve fornire il proprio costruttore. Nel costruttore della classe derivata, chiamare il costruttore `CDaoRecordset::CDaoRecordset`, passando i parametri appropriati.

Passare NULL al costruttore `CDaoDatabase` del recordset per fare in modo che un oggetto venga costruito e connesso automaticamente. Si tratta di un collegamento utile che non `CDaoDatabase` richiede la costruzione e la connessione di un oggetto prima di costruire il recordset. Se `CDaoDatabase` l'oggetto non è aperto, verrà creato anche un oggetto [CDaoWorkspace](../../mfc/reference/cdaoworkspace-class.md) che utilizza l'area di lavoro predefinita. Per ulteriori informazioni, vedere [CDaoDatabase::CDaoDatabase](../../mfc/reference/cdaodatabase-class.md#cdaodatabase).

## <a name="cdaorecordsetclose"></a><a name="close"></a>CDaoRecordset::Chiudi

La `CDaoRecordset` chiusura di un oggetto lo rimuove dalla raccolta di recordset aperti nel database associato.

```
virtual void Close();
```

### <a name="remarks"></a>Osservazioni

Poiché `Close` l'oggetto `CDaoRecordset` non viene eliminato definitivamente, è possibile riutilizzarlo chiamando `Open` la stessa origine dati o un'origine dati diversa.

Tutte le istruzioni [AddNew](#addnew) o [Edit](#edit) in sospeso vengono annullate e viene eseguito il rollback di tutte le transazioni in sospeso. Se si desidera mantenere le aggiunte [Update](#update) o le `Close` modifiche in sospeso, chiamare Update prima di chiamare per ogni recordset.

È possibile `Open` chiamare `Close`nuovamente dopo aver chiamato . Ciò consente di riutilizzare l'oggetto recordset. Un'alternativa migliore consiste nel chiamare [Requery](#requery), se possibile.

Per informazioni correlate, vedere l'argomento "Metodo Close" nella Guida in linea di DAO.

## <a name="cdaorecordsetdelete"></a><a name="delete"></a>CDaoRecordset::Delete

Chiamare questa funzione membro per eliminare il record corrente in un oggetto recordset aperto di tipo dynaset o di tipo tabella.

```
virtual void Delete();
```

### <a name="remarks"></a>Osservazioni

Dopo un'eliminazione riuscita, i membri dati di campo del recordset vengono impostati su un valore Null ed è necessario chiamare in modo esplicito una delle funzioni membro di navigazione del recordset ( [Move](#move), [Seek](#seek), [SetBookmark](#setbookmark)e così via) per spostarsi all'esterno del record eliminato. Quando si eliminano record da un recordset, deve essere `Delete`presente un record corrente nel recordset prima di chiamare ; in caso contrario, MFC genera un'eccezione.

`Delete`rimuove il record corrente e lo rende inaccessibile. Sebbene non sia possibile modificare o utilizzare il record eliminato, questo rimane corrente. Una volta che si passa a un altro record, tuttavia, non è possibile rendere corrente il record eliminato.

> [!CAUTION]
> Il recordset deve essere aggiornabile e deve essere presente un `Delete`record valido nel recordset quando si chiama . Ad esempio, se si elimina un record ma non `Delete` si `Delete` scorre su un nuovo record prima di chiamare di nuovo, viene generata [un'eccezione CDaoException](../../mfc/reference/cdaoexception-class.md).

È possibile annullare l'eliminazione di un record se si utilizzano transazioni e si chiama la funzione membro [CDaoWorkspace::Rollback](../../mfc/reference/cdaoworkspace-class.md#rollback) . Se la tabella di base è la tabella primaria in una relazione di eliminazione a catena, l'eliminazione del record corrente può anche eliminare uno o più record in una tabella esterna. Per ulteriori informazioni, vedere la definizione "eliminazione a catena" nella Guida in linea di DAO.

A `AddNew` `Edit`differenza di `Delete` e , una chiamata `Update`a non è seguita da una chiamata a .

Per informazioni correlate, vedere gli argomenti "AddNew Method", "Edit Method", "Delete Method", "Update Method" e "Updatable Property" nella Guida in linea di DAO.

## <a name="cdaorecordsetdofieldexchange"></a><a name="dofieldexchange"></a>CDaoRecordset::DoFieldExchange

Il framework chiama questa funzione membro per scambiare automaticamente i dati tra i membri dati di campo dell'oggetto recordset e le colonne corrispondenti del record corrente nell'origine dati.

```
virtual void DoFieldExchange(CDaoFieldExchange* pFX);
```

### <a name="parameters"></a>Parametri

*pFX*<br/>
Contiene un puntatore a un `CDaoFieldExchange` oggetto. Il framework avrà già impostato questo oggetto per specificare un contesto per l'operazione di scambio di campo.

### <a name="remarks"></a>Osservazioni

Associa inoltre i membri dati di parametro, se presenti, ai segnaposto di parametro nella stringa dell'istruzione SQL per la selezione del recordset. Lo scambio di dati di campo, denominato DaO record field exchange (DFX), funziona in entrambe le direzioni: dai membri dati di campo dell'oggetto recordset ai campi del record nell'origine dati e dal record nell'origine dati all'oggetto recordset. Se si associano colonne in modo `DoFieldExchange`dinamico, non è necessario implementare .

L'unica azione che è `DoFieldExchange` in genere necessario eseguire per implementare per la classe recordset derivata consiste nel creare la classe con ClassWizard e specificare i nomi e i tipi di dati dei membri dati di campo. È anche possibile aggiungere codice a ciò che ClassWizard scrive per specificare i membri dati di parametro. Se tutti i campi devono essere associati in modo dinamico, questa funzione sarà inattiva a meno che non si specifichino membri dati di parametro.

Quando si dichiara la classe recordset derivata con `DoFieldExchange` ClassWizard, la procedura guidata scrive automaticamente un override di, analogamente all'esempio seguente:

[!code-cpp[NVC_MFCDatabase#2](../../mfc/codesnippet/cpp/cdaorecordset-class_2.cpp)]

## <a name="cdaorecordsetedit"></a><a name="edit"></a>CDaoRecordset::Modifica

Chiamare questa funzione membro per consentire le modifiche al record corrente.

```
virtual void Edit();
```

### <a name="remarks"></a>Osservazioni

Una volta `Edit` chiamata la funzione membro, le modifiche apportate ai campi del record corrente vengono copiate nel buffer di copia. Dopo aver apportato le modifiche `Update` desiderate al record, chiamare per salvare le modifiche. `Edit`salva i valori dei membri dati del recordset. Se si `Edit`chiama , si `Edit` apportano modifiche e quindi si chiama di `Edit` nuovo, i valori del record vengono ripristinati a quelli che erano prima della prima chiamata.

> [!CAUTION]
> Se si modifica un record e quindi si esegue `Update`qualsiasi operazione che si sposta su un altro record senza prima chiamare , le modifiche andranno perse senza alcun avviso. Inoltre, se si chiude il recordset o il database padre, il record modificato viene eliminato senza alcun avviso.

In alcuni casi, è possibile aggiornare una colonna rendendola Null (che non contiene dati). A tale scopo, chiamare `SetFieldNull` con un parametro TRUE per contrassegnare il campo Null; in questo modo anche la colonna da aggiornare. Se si desidera che un campo venga scritto nell'origine dati `SetFieldDirty` anche se il relativo valore non è stato modificato, chiamare con un parametro TRUE. Questo funziona anche se il campo ha il valore Null.

Il framework contrassegna i membri dati di campo modificati per garantire che verranno scritti nel record nell'origine dati dal meccanismo DFX (Record Field Exchange) DAO. La modifica del valore di un campo in genere imposta il campo dirty automaticamente, pertanto raramente sarà necessario chiamare [SetFieldDirty](#setfielddirty) manualmente, ma a volte potrebbe essere necessario assicurarsi che le colonne vengano aggiornate o inserite in modo esplicito indipendentemente dal valore nel membro dati del campo. Il meccanismo DFX utilizza anche l'utilizzo di **PSEUDO NULL**. Per ulteriori informazioni, vedere [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Se il meccanismo del doppio buffer non viene utilizzato, la modifica del valore del campo non imposta automaticamente il campo come dirty. In questo caso, sarà necessario impostare in modo esplicito il campo dirty. Il flag contenuto in [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controlla questo controllo automatico dei campi.

Quando l'oggetto recordset è bloccato in modo pessimistico in `Edit` un ambiente multiutente, il record rimane bloccato dal momento in cui viene utilizzato fino al completamento dell'aggiornamento. Se il recordset è bloccato in modo ottimistico, il record viene bloccato e confrontato con il record pre-modificato prima dell'aggiornamento nel database. Se il record è `Edit`stato `Update` modificato da quando è stato chiamato , l'operazione ha esito negativo e MFC genera un'eccezione. È possibile modificare la `SetLockingMode`modalità di blocco con .

> [!NOTE]
> Il blocco ottimistico viene sempre utilizzato in formati di database esterni, ad esempio ODBC e ISAM installabile.

Il record corrente rimane `Edit`aggiornato dopo aver chiamato . Per `Edit`chiamare , deve essere presente un record corrente. Se non è presente alcun record corrente o se il recordset non fa riferimento a un oggetto recordset aperto di tipo tabella o dynaset, si verifica un'eccezione. La `Edit` chiamata `CDaoException` determina la thrown in grado di generare un oggetto nelle condizioni seguenti:Calling causes a to be thrown under the following conditions:

- Non è presente nessun record corrente.

- Il database o il recordset è di sola lettura.

- Nessun campo nel record è aggiornabile.

- Il database o il recordset è stato aperto per l'utilizzo esclusivo da parte di un altro utente.

- Un altro utente ha bloccato la pagina contenente il record.

Se l'origine dati supporta le transazioni, è possibile effettuare la `Edit` chiamata parte di una transazione. Si noti `CDaoWorkspace::BeginTrans` che `Edit` è necessario chiamare prima di chiamare e dopo l'apertura del recordset. Si noti `CDaoWorkspace::CommitTrans` inoltre che la `Update` chiamata `Edit` non sostituisce la chiamata per completare l'operazione. Per ulteriori informazioni sulle transazioni, vedere classe `CDaoWorkspace`.

Per informazioni correlate, vedere gli argomenti "AddNew Method", "Edit Method", "Delete Method", "Update Method" e "Updatable Property" nella Guida in linea di DAO.

## <a name="cdaorecordsetfillcache"></a><a name="fillcache"></a>CDaoRecordset::FillCache

Chiamare questa funzione membro per memorizzare nella cache un numero specificato di record dal recordset.

```
void FillCache(
    long* pSize = NULL,
    COleVariant* pBookmark = NULL);
```

### <a name="parameters"></a>Parametri

*pDimensioni*<br/>
Specifica il numero di righe da inserire nella cache. Se si ometti questo parametro, il valore è determinato dall'impostazione della proprietà CacheSize dell'oggetto DAO sottostante.

*pSegnalibro*<br/>
Oggetto [COleVariant](../../mfc/reference/colevariant-class.md) che specifica un segnalibro. La cache viene riempita a partire dal record indicato da questo segnalibro. Se si ometti questo parametro, la cache viene compilata a partire dal record indicato dalla proprietà CacheStart dell'oggetto DAO sottostante.

### <a name="remarks"></a>Osservazioni

La memorizzazione nella cache migliora le prestazioni di un'applicazione che recupera o recupera dati da un server remoto. Una cache è uno spazio nella memoria locale che contiene i dati recuperati più di recente dal server presupponendo che i dati verranno probabilmente richiesti nuovamente durante l'esecuzione dell'applicazione. Quando vengono richiesti i dati, il modulo di gestione di database Microsoft Jet controlla prima la cache per i dati anziché recuperarla dal server, operazione che richiede più tempo. L'utilizzo della memorizzazione dei dati nella cache su origini dati non ODBC non ha alcun effetto in quanto i dati non vengono salvati nella cache.

Anziché attendere che la cache venga riempita con i record durante il recupero, `FillCache` è possibile riempire in modo esplicito la cache in qualsiasi momento chiamando la funzione membro. Questo è un modo più `FillCache` veloce per riempire la cache perché recupera più record contemporaneamente anziché uno alla volta. Ad esempio, mentre viene visualizzata ogni schermata dei record, è possibile fare in modo che la chiamata `FillCache` dell'applicazione recuperi lo screenful successivo.

Qualsiasi database ODBC a cui si accede con oggetti recordset può avere una cache locale. Per creare la cache, aprire un oggetto recordset dall'origine dati remota, quindi chiamare le `SetCacheSize` funzioni membro e `SetCacheStart` del recordset. Se *lSize* e *lBookmark* creano un intervallo parzialmente o `SetCacheSize` interamente esterno all'intervallo specificato da e `SetCacheStart`, la parte del recordset al di fuori di questo intervallo viene ignorata e non caricata nella cache. Se `FillCache` le richieste rimangono più record di quelli che rimangono nell'origine dati remota, vengono recuperati solo i record rimanenti e non viene generata alcuna eccezione.

I record recuperati dalla cache non riflettono le modifiche apportate contemporaneamente ai dati di origine da altri utenti.

`FillCache`recupera solo i record non già memorizzati nella cache. Per forzare un aggiornamento di tutti `SetCacheSize` i dati memorizzati nella cache, `SetCacheSize` chiamare la funzione membro con un parametro *lSize* uguale a 0, chiamare nuovamente con il parametro *lSize* uguale alla dimensione della cache richiesta in origine e quindi chiamare `FillCache`.

Per informazioni correlate, vedere l'argomento "Metodo FillCache" nella Guida in linea di DAO.

## <a name="cdaorecordsetfind"></a><a name="find"></a>CDaoRecordset::Find

Chiamare questa funzione membro per individuare una determinata stringa in un recordset di tipo dynaset o snapshot utilizzando un operatore di confronto.

```
virtual BOOL Find(
    long lFindType,
    LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parametri

*LFindType (tipo in cui si trova il nome*<br/>
Valore che indica il tipo di operazione di ricerca desiderata. I valori possibili sono:

- AFX_DAO_NEXT trovare la posizione successiva di una stringa corrispondente.

- AFX_DAO_PREV trovare la posizione precedente di una stringa corrispondente.

- AFX_DAO_FIRST Trovare la prima posizione di una stringa corrispondente.

- AFX_DAO_LAST trovare l'ultima posizione di una stringa corrispondente.

*Filtro di lpsz*<br/>
Espressione stringa (ad esempio la clausola **WHERE** in un'istruzione SQL senza la parola **WHERE**) utilizzata per individuare il record. Ad esempio:

[!code-cpp[NVC_MFCDatabase#3](../../mfc/codesnippet/cpp/cdaorecordset-class_3.cpp)]

### <a name="return-value"></a>Valore restituito

Diverso da zero se vengono trovati record corrispondenti, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

È possibile trovare la prima, successiva, precedente o ultima istanza della stringa. `Find`è una funzione virtuale, pertanto è possibile eseguirne l'override e aggiungere la propria implementazione. Le `FindFirst` `FindLast`funzioni `FindNext`membro `FindPrev` , , `Find` , e chiamano `Find` la funzione membro, pertanto è possibile utilizzare per controllare il comportamento di tutte le operazioni Find.

Per individuare un record in un recordset di tipo tabella, chiamare il [Seek](#seek) funzione membro.

> [!TIP]
> Più piccolo è il set di `Find` record di cui si dispone, più efficace sarà. In generale, e in particolare con i dati ODBC, è preferibile creare una nuova query che recupera solo i record desiderati.

Per informazioni correlate, vedere l'argomento "FindFirst, FindLast, FindNext, FindPrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetfindfirst"></a><a name="findfirst"></a>CDaoRecordset::FindFirst

Chiamare questa funzione membro per trovare il primo record che corrisponde a una condizione specificata.

```
BOOL FindFirst(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parametri

*Filtro di lpsz*<br/>
Espressione stringa (ad esempio la clausola **WHERE** in un'istruzione SQL senza la parola **WHERE**) utilizzata per individuare il record.

### <a name="return-value"></a>Valore restituito

Diverso da zero se vengono trovati record corrispondenti, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

La `FindFirst` funzione membro inizia la ricerca dall'inizio del recordset e esegue la ricerca fino alla fine del recordset.

Se si desidera includere tutti i record nella ricerca (non solo quelli che soddisfano una condizione specifica), utilizzare una delle operazioni di spostamento per spostarsi da un record all'altro. Per individuare un record in un recordset `Seek` di tipo tabella, chiamare la funzione membro.

Se non viene individuato un record corrispondente ai criteri, il puntatore del record corrente non viene determinato e `FindFirst` restituisce zero. Se il recordset contiene più di un record che `FindFirst` soddisfa i criteri, `FindNext` individua la prima occorrenza, individua l'occorrenza successiva e così via.

> [!CAUTION]
> Se si modifica il record corrente, assicurarsi `Update` di salvare le modifiche chiamando la funzione membro prima di passare a un altro record. Se ci si sposta su un altro record senza eseguire l'aggiornamento, le modifiche andranno perse senza alcun avviso.

Le `Find` funzioni membro eseguono la ricerca dalla posizione e nella direzione specificata nella tabella seguente:

|Operazioni di ricerca|Begin|Direzione di ricerca|
|---------------------|-----------|----------------------|
|`FindFirst`|Inizio del recordset|Fine del recordset|
|`FindLast`|Fine del recordset|Inizio del recordset|
|`FindNext`|Record corrente|Fine del recordset|
|`FindPrevious`|Record corrente|Inizio del recordset|

> [!NOTE]
> Quando si `FindLast`chiama , il modulo di gestione di database Microsoft Jet popola completamente il recordset prima di iniziare la ricerca, se questa operazione non è già stata eseguita. La prima ricerca potrebbe richiedere più tempo delle ricerche successive.

L'utilizzo di una delle operazioni `MoveFirst` Find `MoveNext`non equivale a chiamare o , tuttavia, il che rende semplicemente corrente il primo o il record successivo senza specificare una condizione. È possibile seguire un'operazione Trova con un'operazione di spostamento.

Quando si utilizzano le operazioni Trova, tenere presente quanto segue:

- Se `Find` restituisce un valore diverso da zero, il record corrente non è definito. In questo caso, è necessario posizionare il puntatore del record corrente su un record valido.

- Non è possibile utilizzare un'operazione Find con un recordset di tipo snapshot a scorrimento forward-only.

- È consigliabile utilizzare il formato di data statunitense (mese-giorno-anno) quando si cercano campi contenenti date, anche se non si utilizza la versione statunitense del modulo di gestione di database Microsoft Jet. in caso contrario, i record corrispondenti potrebbero non essere trovati.

- Quando si lavora con database ODBC e dynaset di grandi dimensioni, è possibile scoprire che l'utilizzo delle operazioni di ricerca è lento, soprattutto quando si lavora con recordset di grandi dimensioni. È possibile migliorare le prestazioni utilizzando query SQL con clausole **ORDERBY** o **WHERE** personalizzate, query con parametri o `CDaoQuerydef` oggetti che recuperano record indicizzati specifici.

Per informazioni correlate, vedere l'argomento "FindFirst, FindLast, FindNext, FindPrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetfindlast"></a><a name="findlast"></a>CDaoRecordset::FindLast

Chiamare questa funzione membro per trovare l'ultimo record che corrisponde a una condizione specificata.

```
BOOL FindLast(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parametri

*Filtro di lpsz*<br/>
Espressione stringa (ad esempio la clausola **WHERE** in un'istruzione SQL senza la parola **WHERE**) utilizzata per individuare il record.

### <a name="return-value"></a>Valore restituito

Diverso da zero se vengono trovati record corrispondenti, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

La `FindLast` funzione membro inizia la ricerca alla fine del recordset e esegue la ricerca all'indietro verso l'inizio del recordset.

Se si desidera includere tutti i record nella ricerca (non solo quelli che soddisfano una condizione specifica), utilizzare una delle operazioni di spostamento per spostarsi da un record all'altro. Per individuare un record in un recordset `Seek` di tipo tabella, chiamare la funzione membro.

Se non viene individuato un record corrispondente ai criteri, il puntatore del record corrente non viene determinato e `FindLast` restituisce zero. Se il recordset contiene più di un record che `FindFirst` soddisfa i criteri, `FindNext` individua la prima occorrenza, individua l'occorrenza successiva alla prima occorrenza e così via.

> [!CAUTION]
> Se si modifica il record corrente, assicurarsi `Update` di salvare le modifiche chiamando la funzione membro prima di passare a un altro record. Se ci si sposta su un altro record senza eseguire l'aggiornamento, le modifiche andranno perse senza alcun avviso.

L'utilizzo di una delle operazioni `MoveFirst` Find `MoveNext`non equivale a chiamare o , tuttavia, il che rende semplicemente corrente il primo o il record successivo senza specificare una condizione. È possibile seguire un'operazione Trova con un'operazione di spostamento.

Quando si utilizzano le operazioni Trova, tenere presente quanto segue:

- Se `Find` restituisce un valore diverso da zero, il record corrente non è definito. In questo caso, è necessario posizionare il puntatore del record corrente su un record valido.

- Non è possibile utilizzare un'operazione Find con un recordset di tipo snapshot a scorrimento forward-only.

- È consigliabile utilizzare il formato di data statunitense (mese-giorno-anno) quando si cercano campi contenenti date, anche se non si utilizza la versione statunitense del modulo di gestione di database Microsoft Jet. in caso contrario, i record corrispondenti potrebbero non essere trovati.

- Quando si lavora con database ODBC e dynaset di grandi dimensioni, è possibile scoprire che l'utilizzo delle operazioni di ricerca è lento, soprattutto quando si lavora con recordset di grandi dimensioni. È possibile migliorare le prestazioni utilizzando query SQL con clausole **ORDERBY** o **WHERE** personalizzate, query con parametri o `CDaoQuerydef` oggetti che recuperano record indicizzati specifici.

Per informazioni correlate, vedere l'argomento "FindFirst, FindLast, FindNext, FindPrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetfindnext"></a><a name="findnext"></a>CDaoRecordset::FindNext

Chiamare questa funzione membro per trovare il record successivo che corrisponde a una condizione specificata.

```
BOOL FindNext(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parametri

*Filtro di lpsz*<br/>
Espressione stringa (ad esempio la clausola **WHERE** in un'istruzione SQL senza la parola **WHERE**) utilizzata per individuare il record.

### <a name="return-value"></a>Valore restituito

Diverso da zero se vengono trovati record corrispondenti, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

La `FindNext` funzione membro inizia la ricerca in corrispondenza del record corrente e esegue la ricerca alla fine del recordset.

Se si desidera includere tutti i record nella ricerca (non solo quelli che soddisfano una condizione specifica), utilizzare una delle operazioni di spostamento per spostarsi da un record all'altro. Per individuare un record in un recordset `Seek` di tipo tabella, chiamare la funzione membro.

Se non viene individuato un record corrispondente ai criteri, il puntatore del record corrente non viene determinato e `FindNext` restituisce zero. Se il recordset contiene più di un record che `FindFirst` soddisfa i criteri, `FindNext` individua la prima occorrenza, individua l'occorrenza successiva e così via.

> [!CAUTION]
> Se si modifica il record corrente, assicurarsi `Update` di salvare le modifiche chiamando la funzione membro prima di passare a un altro record. Se ci si sposta su un altro record senza eseguire l'aggiornamento, le modifiche andranno perse senza alcun avviso.

L'utilizzo di una delle operazioni `MoveFirst` Find `MoveNext`non equivale a chiamare o , tuttavia, il che rende semplicemente corrente il primo o il record successivo senza specificare una condizione. È possibile seguire un'operazione Trova con un'operazione di spostamento.

Quando si utilizzano le operazioni Trova, tenere presente quanto segue:

- Se `Find` restituisce un valore diverso da zero, il record corrente non è definito. In questo caso, è necessario posizionare il puntatore del record corrente su un record valido.

- Non è possibile utilizzare un'operazione Find con un recordset di tipo snapshot a scorrimento forward-only.

- È consigliabile utilizzare il formato di data statunitense (mese-giorno-anno) quando si cercano campi contenenti date, anche se non si utilizza la versione statunitense del modulo di gestione di database Microsoft Jet. in caso contrario, i record corrispondenti potrebbero non essere trovati.

- Quando si lavora con database ODBC e dynaset di grandi dimensioni, è possibile scoprire che l'utilizzo delle operazioni di ricerca è lento, soprattutto quando si lavora con recordset di grandi dimensioni. È possibile migliorare le prestazioni utilizzando query SQL con clausole **ORDERBY** o **WHERE** personalizzate, query con parametri o `CDaoQuerydef` oggetti che recuperano record indicizzati specifici.

Per informazioni correlate, vedere l'argomento "FindFirst, FindLast, FindNext, FindPrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetfindprev"></a><a name="findprev"></a>CDaoRecordset::FindPrev

Chiamare questa funzione membro per trovare il record precedente che corrisponde a una condizione specificata.

```
BOOL FindPrev(LPCTSTR lpszFilter);
```

### <a name="parameters"></a>Parametri

*Filtro di lpsz*<br/>
Espressione stringa (ad esempio la clausola **WHERE** in un'istruzione SQL senza la parola **WHERE**) utilizzata per individuare il record.

### <a name="return-value"></a>Valore restituito

Diverso da zero se vengono trovati record corrispondenti, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

La `FindPrev` funzione membro inizia la ricerca in corrispondenza del record corrente e esegue la ricerca all'indietro verso l'inizio del recordset.

Se si desidera includere tutti i record nella ricerca (non solo quelli che soddisfano una condizione specifica), utilizzare una delle operazioni di spostamento per spostarsi da un record all'altro. Per individuare un record in un recordset `Seek` di tipo tabella, chiamare la funzione membro.

Se non viene individuato un record corrispondente ai criteri, il puntatore del record corrente non viene determinato e `FindPrev` restituisce zero. Se il recordset contiene più di un record che `FindFirst` soddisfa i criteri, `FindNext` individua la prima occorrenza, individua l'occorrenza successiva e così via.

> [!CAUTION]
> Se si modifica il record corrente, assicurarsi `Update` di salvare le modifiche chiamando la funzione membro prima di passare a un altro record. Se ci si sposta su un altro record senza eseguire l'aggiornamento, le modifiche andranno perse senza alcun avviso.

L'utilizzo di una delle operazioni `MoveFirst` Find `MoveNext`non equivale a chiamare o , tuttavia, il che rende semplicemente corrente il primo o il record successivo senza specificare una condizione. È possibile seguire un'operazione Trova con un'operazione di spostamento.

Quando si utilizzano le operazioni Trova, tenere presente quanto segue:

- Se `Find` restituisce un valore diverso da zero, il record corrente non è definito. In questo caso, è necessario posizionare il puntatore del record corrente su un record valido.

- Non è possibile utilizzare un'operazione Find con un recordset di tipo snapshot a scorrimento forward-only.

- È consigliabile utilizzare il formato di data statunitense (mese-giorno-anno) quando si cercano campi contenenti date, anche se non si utilizza la versione statunitense del modulo di gestione di database Microsoft Jet. in caso contrario, i record corrispondenti potrebbero non essere trovati.

- Quando si lavora con database ODBC e dynaset di grandi dimensioni, è possibile scoprire che l'utilizzo delle operazioni di ricerca è lento, soprattutto quando si lavora con recordset di grandi dimensioni. È possibile migliorare le prestazioni utilizzando query SQL con clausole **ORDERBY** o **WHERE** personalizzate, query con parametri o `CDaoQuerydef` oggetti che recuperano record indicizzati specifici.

Per informazioni correlate, vedere l'argomento "FindFirst, FindLast, FindNext, FindPrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetabsoluteposition"></a><a name="getabsoluteposition"></a>CDaoRecordset::GetAbsolutePosition

Restituisce il numero di record del record corrente di un oggetto recordset.

```
long GetAbsolutePosition();
```

### <a name="return-value"></a>Valore restituito

Un numero intero compreso tra 0 e il numero di record nel recordset. Corrisponde alla posizione ordinale del record corrente nel recordset.

### <a name="remarks"></a>Osservazioni

Il AbsolutePosition valore della proprietà dell'oggetto DAO sottostante è in base zero; l'impostazione 0 si riferisce al primo record del recordset. È possibile determinare il numero di record popolati nel recordset chiamando [GetRecordCount](#getrecordcount). La `GetRecordCount` chiamata può richiedere del tempo perché deve accedere a tutti i record per determinare il conteggio.

Se non è presente alcun record corrente, come quando non sono presenti record nel recordset, viene restituito - 1. Se il record corrente viene eliminato, il Valore della proprietà AbsolutePosition non è definito e MFC genera un'eccezione se vi viene fatto riferimento. Per i recordset di tipo dynaset, i nuovi record vengono aggiunti alla fine della sequenza.

> [!NOTE]
> Questa proprietà non deve essere utilizzata come numero di record surrogato. I segnalibri sono ancora il modo consigliato per mantenere e tornare a una determinata posizione e sono l'unico modo per posizionare il record corrente in tutti i tipi di oggetti recordset. In particolare, la posizione di un determinato record cambia quando i record che lo precedono vengono eliminati. Non vi è inoltre alcuna garanzia che un determinato record avrà la stessa posizione assoluta se il recordset viene ricreato nuovamente perché l'ordine dei singoli record all'interno di un recordset non è garantito a meno che non venga creato con un'istruzione SQL utilizzando una clausola **ORDERBY.**

> [!NOTE]
> Questa funzione membro è valida solo per i recordset di tipo dynaset e snapshot.

Per informazioni correlate, vedere l'argomento "Proprietà AbsolutePosition" nella Guida di DAO.

## <a name="cdaorecordsetgetbookmark"></a><a name="getbookmark"></a>CDaoRecordset::GetBookmark

Chiamare questa funzione membro per ottenere il valore del segnalibro in un record specifico.

```
COleVariant GetBookmark();
```

### <a name="return-value"></a>Valore restituito

Restituisce un valore che rappresenta il segnalibro nel record corrente.

### <a name="remarks"></a>Osservazioni

Quando un oggetto recordset viene creato o aperto, ognuno dei relativi record dispone già di un segnalibro univoco, se supportato. Chiamata `CanBookmark` per determinare se un recordset supporta i segnalibri.

È possibile salvare il segnalibro per il record corrente `COleVariant` assegnando il valore del segnalibro a un oggetto. Per tornare rapidamente a tale record in qualsiasi momento `SetBookmark` dopo lo spostamento a `COleVariant` un record diverso, chiamare con un parametro corrispondente al valore di tale oggetto.

> [!NOTE]
> La chiamata a [Requery](#requery) modifica i segnalibri DAO.

Per informazioni correlate, vedere l'argomento "Proprietà Bookmark" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetcachesize"></a><a name="getcachesize"></a>CDaoRecordset::GetCacheSize

Chiamare questa funzione membro per ottenere il numero di record memorizzati nella cache.

```
long GetCacheSize();
```

### <a name="return-value"></a>Valore restituito

Valore che specifica il numero di record in un recordset di tipo dynaset contenente dati da memorizzare localmente nella cache da un'origine dati ODBC.

### <a name="remarks"></a>Osservazioni

La memorizzazione dei dati nella cache migliora le prestazioni di un'applicazione che recupera i dati da un server remoto tramite oggetti recordset di tipo dynaset. Una cache è uno spazio nella memoria locale che contiene i dati recuperati più di recente dal server nel caso in cui i dati verranno richiesti nuovamente durante l'esecuzione dell'applicazione. Quando vengono richiesti i dati, il modulo di gestione di database Microsoft Jet controlla prima la cache per i dati richiesti anziché recuperarla dal server, operazione che richiede più tempo. I dati che non provengono da un'origine dati ODBC non vengono salvati nella cache.

Qualsiasi origine dati ODBC, ad esempio una tabella collegata, può avere una cache locale.

Per informazioni correlate, vedere l'argomento "CacheSize, CacheStart Properties" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetcachestart"></a><a name="getcachestart"></a>CDaoRecordset::GetCacheStart

Chiamare questa funzione membro per ottenere il valore del segnalibro del primo record nel recordset da memorizzare nella cache.

```
COleVariant GetCacheStart();
```

### <a name="return-value"></a>Valore restituito

Oggetto `COleVariant` che specifica il segnalibro del primo record del recordset da memorizzare nella cache.

### <a name="remarks"></a>Osservazioni

Il modulo di gestione di database Microsoft Jet richiede i record all'interno dell'intervallo della cache dalla cache e richiede i record al di fuori dell'intervallo di cache dal server.

> [!NOTE]
> I record recuperati dalla cache non riflettono le modifiche apportate contemporaneamente ai dati di origine da altri utenti.

Per informazioni correlate, vedere l'argomento "CacheSize, CacheStart Properties" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetcurrentindex"></a><a name="getcurrentindex"></a>CDaoRecordset::GetCurrentIndex

Chiamare questa funzione membro per determinare l'indice attualmente `CDaoRecordset` in uso in un oggetto di tipo tabella indicizzato.

```
CString GetCurrentIndex();
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` contenente il nome dell'indice attualmente in uso con un recordset di tipo tabella. Restituisce una stringa vuota se non è stato impostato alcun indice.

### <a name="remarks"></a>Osservazioni

Questo indice è la base per ordinare i record in un recordset di tipo tabella e viene utilizzato dalla funzione membro [Seek](#seek) per individuare i record.

Un `CDaoRecordset` oggetto può avere più di un indice, ma può utilizzare un solo indice alla volta (anche se un [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) oggetto può avere più indici definiti su di esso).

Per informazioni correlate, vedere l'argomento "Oggetto Index" e la definizione "indice corrente" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetdatecreated"></a><a name="getdatecreated"></a>CDaoRecordset::GetDateCreated

Chiamare questa funzione membro per recuperare la data e l'ora di creazione di una tabella di base.

```
COleDateTime GetDateCreated();
```

### <a name="return-value"></a>Valore restituito

Oggetto [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) oggetto contenente la data e l'ora di creazione della tabella di base.

### <a name="remarks"></a>Osservazioni

Le impostazioni di data e ora derivano dal computer in cui è stata creata la tabella di base.

Per informazioni correlate, vedere l'argomento "Proprietà DateCreated, LastUpdated" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetdatelastupdated"></a><a name="getdatelastupdated"></a>CDaoRecordset::GetDateLastUpdated

Chiamare questa funzione membro per recuperare la data e l'ora dell'ultimo aggiornamento dello schema.

```
COleDateTime GetDateLastUpdated();
```

### <a name="return-value"></a>Valore restituito

Oggetto [COleDateTime](../../atl-mfc-shared/reference/coledatetime-class.md) oggetto contenente la data e l'ora dell'ultimo aggiornamento della struttura della tabella di base (schema).

### <a name="remarks"></a>Osservazioni

Le impostazioni di data e ora derivano dal computer in cui è stato aggiornato la struttura della tabella di base (schema).

Per informazioni correlate, vedere l'argomento "Proprietà DateCreated, LastUpdated" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetdefaultdbname"></a><a name="getdefaultdbname"></a>CDaoRecordset::GetDefaultDBName

Chiamare questa funzione membro per determinare il nome del database per questo recordset.

```
virtual CString GetDefaultDBName();
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` che contiene il percorso e il nome del database da cui deriva il recordset.

### <a name="remarks"></a>Osservazioni

Se un recordset viene creato senza un puntatore a [CDaoDatabase](../../mfc/reference/cdaodatabase-class.md), questo percorso viene utilizzato dal recordset per aprire il database predefinito. Per impostazione predefinita, questa funzione restituisce una stringa vuota. Quando ClassWizard deriva un `CDaoRecordset`nuovo recordset da , creerà automaticamente questa funzione.

Nell'esempio seguente viene illustrato l'utilizzo\\\\della doppia barra rovesciata ( ) nella stringa, come è necessario affinché la stringa venga interpretata correttamente.

[!code-cpp[NVC_MFCDatabase#4](../../mfc/codesnippet/cpp/cdaorecordset-class_4.cpp)]

## <a name="cdaorecordsetgetdefaultsql"></a><a name="getdefaultsql"></a>CDaoRecordset::GetDefaultSQL

Il framework chiama questa funzione membro per ottenere l'istruzione SQL predefinita su cui è basato il recordset.

```
virtual CString GetDefaultSQL();
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` che contiene l'istruzione SQL predefinita.

### <a name="remarks"></a>Osservazioni

Potrebbe trattarsi di un nome di tabella o di un'istruzione SQL **SELECT.**

L'istruzione SQL predefinita viene definita indirettamente dichiarando la classe recordset con ClassWizard e ClassWizard esegue automaticamente questa attività.

Se si passa una stringa SQL null a [Open](#open), questa funzione viene chiamata per determinare il nome della tabella o SQL per il recordset.

## <a name="cdaorecordsetgeteditmode"></a><a name="geteditmode"></a>CDaoRecordset::GetEditMode

Chiamare questa funzione membro per determinare lo stato di modifica, che è uno dei seguenti valori:

```
short GetEditMode();
```

### <a name="return-value"></a>Valore restituito

Restituisce un valore che indica lo stato di modifica del record corrente.

### <a name="remarks"></a>Osservazioni

|valore|Descrizione|
|-----------|-----------------|
|`dbEditNone`|Non è in corso alcuna operazione di modifica.|
|`dbEditInProgress`|È stato chiamato `Edit`.|
|`dbEditAdd`|È stato chiamato `AddNew`.|

Per informazioni correlate, vedere l'argomento "Proprietà EditMode" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetfieldcount"></a><a name="getfieldcount"></a>CDaoRecordset::GetFieldCount

Chiamare questa funzione membro per recuperare il numero di campi (colonne) definiti nel recordset.

```
short GetFieldCount();
```

### <a name="return-value"></a>Valore restituito

Numero di campi nel recordset.

### <a name="remarks"></a>Osservazioni

Per informazioni correlate, vedere l'argomento "Proprietà Count" nella Guida di DAO.

## <a name="cdaorecordsetgetfieldinfo"></a><a name="getfieldinfo"></a>CDaoRecordset::GetFieldInfo

Chiamare questa funzione membro per ottenere informazioni sui campi in un recordset.

```
void GetFieldInfo(
    int nIndex,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetFieldInfo(
    LPCTSTR lpszName,
    CDaoFieldInfo& fieldinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Parametri

*nIndex*<br/>
Indice in base zero del campo predefinito nell'insieme Fields del recordset, per la ricerca in base all'indice.

*Fieldinfo*<br/>
Riferimento a una struttura [CDaoFieldInfo.](../../mfc/reference/cdaofieldinfo-structure.md)

*dwInfoOptions*<br/>
Opzioni che specificano le informazioni sul recordset da recuperare. Le opzioni disponibili sono elencate qui insieme a ciò che causano la restituzione della funzione. Per ottenere prestazioni ottimali, recuperare solo il livello di informazioni necessario:

- `AFX_DAO_PRIMARY_INFO`(Predefinito) Nome, Tipo, Dimensione, Attributi

- `AFX_DAO_SECONDARY_INFO`Informazioni principali, più: Posizione ordinale, Obbligatorio, Consenti lunghezza zero, Ordine di confronto, Nome straniero, Campo di origine, Tabella di origine

- `AFX_DAO_ALL_INFO`Informazioni primarie e secondarie, oltre a: Valore predefinito, Regola di convalida, Testo di convalida

*lpszName*<br/>
Nome del campo.

### <a name="remarks"></a>Osservazioni

Una versione della funzione consente di cercare un campo in base all'indice. L'altra versione consente di cercare un campo in base al nome.

Per una descrizione delle informazioni restituite, vedere il [CDaoFieldInfo](../../mfc/reference/cdaofieldinfo-structure.md) struttura. Questa struttura dispone di membri che corrispondono agli elementi di informazioni elencati in precedenza nella descrizione di *dwInfoOptions*. Quando richiedi informazioni a un livello, ottieni informazioni anche per tutti i livelli precedenti.

Per informazioni correlate, vedere l'argomento "Proprietà Attributes" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetfieldvalue"></a><a name="getfieldvalue"></a>CDaoRecordset::GetFieldValue

Chiamare questa funzione membro per recuperare i dati in un recordset.

```
virtual void GetFieldValue(
    LPCTSTR lpszName,
    COleVariant& varValue);

virtual void GetFieldValue(
    int nIndex,
    COleVariant& varValue);

virtual COleVariant GetFieldValue(LPCTSTR lpszName);
virtual COleVariant GetFieldValue(int nIndex);
```

### <a name="parameters"></a>Parametri

*lpszName*<br/>
Puntatore a una stringa che contiene il nome di un campo.

*varValue (valore varValue)*<br/>
Riferimento a `COleVariant` un oggetto in cui verrà archiviato il valore di un campo.

*nIndex*<br/>
Indice in base zero del campo nell'insieme Fields del recordset, per la ricerca in base all'indice.

### <a name="return-value"></a>Valore restituito

Le due `GetFieldValue` versioni di che restituiscono un valore restituiscono un [COleVariant](../../mfc/reference/colevariant-class.md) oggetto che contiene il valore di un campo.

### <a name="remarks"></a>Osservazioni

È possibile cercare un campo in base al nome o alla posizione ordinale.

> [!NOTE]
> È più efficiente chiamare una delle versioni di questa `COleVariant` funzione membro che accetta un riferimento a `COleVariant` un oggetto come parametro, anziché chiamare una versione che restituisce un oggetto. Le ultime versioni di questa funzione vengono mantenute per compatibilità con le versioni precedenti.

Utilizzare `GetFieldValue` e [SetFieldValue](#setfieldvalue) per associare dinamicamente i campi in fase di esecuzione anziché associare in modo statico le colonne utilizzando il meccanismo [DoFieldExchange.](#dofieldexchange)

`GetFieldValue`e `DoFieldExchange` il meccanismo può essere combinato per migliorare le prestazioni. Ad esempio, `GetFieldValue` utilizzare per recuperare un valore che è necessario solo su richiesta e assegnare tale chiamata a un pulsante "Informazioni" nell'interfaccia.

Per informazioni correlate, vedere gli argomenti "Oggetto campo" e "Proprietà valore" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetindexcount"></a><a name="getindexcount"></a>CDaoRecordset::GetIndexCount

Chiamare questa funzione membro per determinare il numero di indici disponibili nel recordset di tipo tabella.

```
short GetIndexCount();
```

### <a name="return-value"></a>Valore restituito

Numero di indici nel recordset di tipo tabella.

### <a name="remarks"></a>Osservazioni

`GetIndexCount`è utile per scorrere in ciclo tutti gli indici nel recordset. A tale scopo, utilizzare `GetIndexCount` insieme a [GetIndexInfo](#getindexinfo). Se si chiama questa funzione membro su recordset di tipo dynaset o snapshot, MFC genera un'eccezione.

Per informazioni correlate, vedere l'argomento "Proprietà Attributes" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetindexinfo"></a><a name="getindexinfo"></a>CDaoRecordset::GetIndexInfo

Chiamare questa funzione membro per ottenere vari tipi di informazioni su un indice definito nella tabella di base sottostante un recordset.

```
void GetIndexInfo(
    int nIndex,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

void GetIndexInfo(
    LPCTSTR lpszName,
    CDaoIndexInfo& indexinfo,
    DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
```

### <a name="parameters"></a>Parametri

*nIndex*<br/>
Indice in base zero nell'insieme Indexes della tabella, per la ricerca in base alla posizione numerica.

*indexinfo*<br/>
Riferimento a una struttura [CDaoIndexInfo.](../../mfc/reference/cdaoindexinfo-structure.md)

*dwInfoOptions*<br/>
Opzioni che specificano le informazioni sull'indice da recuperare. Le opzioni disponibili sono elencate qui insieme a ciò che causano la restituzione della funzione. Per ottenere prestazioni ottimali, recuperare solo il livello di informazioni necessario:

- `AFX_DAO_PRIMARY_INFO`(Predefinito) Nome, Informazioni campo, Campi

- `AFX_DAO_SECONDARY_INFO`Informazioni primarie, oltre a: Principale, Univoco, Cluster, IgnoreNulls, Obbligatorio, Estero

- `AFX_DAO_ALL_INFO`Informazioni primarie e secondarie, più: Conteggio distinto

*lpszName*<br/>
Puntatore al nome dell'oggetto indice, per la ricerca in base al nome.

### <a name="remarks"></a>Osservazioni

Una versione della funzione consente di cercare un indice in base alla relativa posizione nella raccolta. L'altra versione consente di cercare un indice in base al nome.

Per una descrizione delle informazioni restituite, vedere il [CDaoIndexInfo](../../mfc/reference/cdaoindexinfo-structure.md) struttura. Questa struttura dispone di membri che corrispondono agli elementi di informazioni elencati in precedenza nella descrizione di *dwInfoOptions*. Quando richiedi informazioni a un livello, ottieni informazioni anche per tutti i livelli precedenti.

Per informazioni correlate, vedere l'argomento "Proprietà Attributes" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetlastmodifiedbookmark"></a><a name="getlastmodifiedbookmark"></a>CDaoRecordset::GetLastModifiedBookmark

Chiamare questa funzione membro per recuperare il segnalibro del record aggiunto o aggiornato più di recente.

```
COleVariant GetLastModifiedBookmark();
```

### <a name="return-value"></a>Valore restituito

Oggetto `COleVariant` contenente un segnalibro che indica il record aggiunto o modificato più di recente.

### <a name="remarks"></a>Osservazioni

Quando un oggetto recordset viene creato o aperto, ognuno dei relativi record dispone già di un segnalibro univoco, se supportato. Chiamare [GetBookmark](#getbookmark) per determinare se il recordset supporta i segnalibri. Se il recordset non supporta `CDaoException` i segnalibri, viene generata un'eccezione .

Quando si aggiunge un record, questo viene visualizzato alla fine del recordset e non è il record corrente. Per rendere corrente il `GetLastModifiedBookmark` nuovo record, chiamare e quindi chiamare `SetBookmark` per tornare al record appena aggiunto.

Per informazioni correlate, vedere l'argomento "Proprietà LastModified" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetlockingmode"></a><a name="getlockingmode"></a>CDaoRecordset::GetLockingMode

Chiamare questa funzione membro per determinare il tipo di blocco attivo per il recordset.

```
BOOL GetLockingMode();
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il tipo di blocco è pessimistico, in caso contrario 0 per il blocco dei record ottimistici.

### <a name="remarks"></a>Osservazioni

Quando è attivo il blocco pessimistico, la pagina di dati contenente il record che si sta modificando viene bloccata non appena si chiama la funzione membro [Edit.](#edit) La pagina viene sbloccata quando si chiama la funzione membro [Update](#update) o [Close](#close) o una delle operazioni Move o Find.

Quando è attivo il blocco ottimistico, la pagina di dati contenente `Update` il record viene bloccata solo durante l'aggiornamento del record con la funzione membro.

Quando si utilizzano origini dati ODBC, la modalità di blocco è sempre ottimistica.

Per informazioni correlate, vedere gli argomenti "Proprietà LockEdits" e "Comportamento di blocco nelle applicazioni multiutente" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetname"></a><a name="getname"></a>CDaoRecordset::GetName

Chiamare questa funzione membro per recuperare il nome del recordset.

```
CString GetName();
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` contenente il nome del recordset.

### <a name="remarks"></a>Osservazioni

Il nome del recordset deve iniziare con una lettera e può contenere un massimo di 40 caratteri. Può includere numeri e caratteri di sottolineatura, ma non può includere punteggiatura o spazi.

Per informazioni correlate, vedere l'argomento "Proprietà Name" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetparamvalue"></a><a name="getparamvalue"></a>CDaoRecordset::GetParamValue

Chiamare questa funzione membro per recuperare il valore corrente del parametro specificato archiviato nell'oggetto DAOParameter sottostante.

```
virtual COleVariant GetParamValue(int nIndex);
virtual COleVariant GetParamValue(LPCTSTR lpszName);
```

### <a name="parameters"></a>Parametri

*nIndex*<br/>
Posizione numerica del parametro nell'oggetto DAOParameter sottostante.

*lpszName*<br/>
Nome del parametro di cui si desidera il valore.

### <a name="return-value"></a>Valore restituito

Oggetto della classe [COleVariant](../../mfc/reference/colevariant-class.md) che contiene il valore del parametro.

### <a name="remarks"></a>Osservazioni

È possibile accedere al parametro in base al nome o alla relativa posizione numerica nella raccolta.

Per informazioni correlate, vedere l'argomento "Oggetto parametro" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetpercentposition"></a><a name="getpercentposition"></a>CDaoRecordset::GetPercentPosition

Quando si utilizza un recordset di tipo dynaset `GetPercentPosition` o snapshot, se si chiama prima di popolare completamente il recordset, la quantità di movimento è relativa al numero di record a cui si accede come indicato chiamando [GetRecordCount](#getrecordcount).

```
float GetPercentPosition();
```

### <a name="return-value"></a>Valore restituito

Numero compreso tra 0 e 100 che indica la posizione approssimativa del record corrente nell'oggetto recordset in base a una percentuale dei record nel recordset.

### <a name="remarks"></a>Osservazioni

È possibile passare all'ultimo record chiamando [MoveLast](#movelast) per completare il popolamento di tutti i recordset, ma questa operazione potrebbe richiedere una quantità significativa di tempo.

È possibile `GetPercentPosition` chiamare su tutti e tre i tipi di oggetti recordset, incluse le tabelle senza indici. Tuttavia, non `GetPercentPosition` è possibile chiamare snapshot a scorrimento forward-only o su un recordset aperto da una query pass-through su un database esterno. Se non è presente alcun record corrente o `CDaoException` se il record corrente è stato eliminato, viene generata un'eccezione.

Per informazioni correlate, vedere l'argomento "Proprietà PercentPosition" nella Guida di DAO.

## <a name="cdaorecordsetgetrecordcount"></a><a name="getrecordcount"></a>CDaoRecordset::GetRecordCount

Chiamare questa funzione membro per scoprire quanti record in un recordset sono stati acceduti.

```
long GetRecordCount();
```

### <a name="return-value"></a>Valore restituito

Restituisce il numero di record a cui si accede in un oggetto recordset.

### <a name="remarks"></a>Osservazioni

`GetRecordCount`non indica quanti record sono contenuti in un recordset di tipo dynaset o snapshot fino a quando non è stato eseguito l'accesso a tutti i record. Questa chiamata di funzione membro può richiedere una notevole quantità di tempo per completare.

Una volta che è stato eseguito l'accesso all'ultimo record, il valore restituito indica il numero totale di record non eliminati nel recordset. Per forzare l'accesso all'ultimo record, chiamare la `MoveLast` funzione membro o `FindLast` per il recordset. È inoltre possibile utilizzare un conteggio SQL per determinare il numero approssimativo di record restituiti dalla query.

Quando l'applicazione elimina i record in un recordset di `GetRecordCount` tipo dynaset, il valore restituito di diminuisce. Tuttavia, i record eliminati da `GetRecordCount` altri utenti non vengono riflessi da fino a quando il record corrente non viene posizionato in un record eliminato. Se si esegue una transazione che influisce sul `GetRecordCount` numero di record e successivamente si esegue il rollback della transazione, non rifletterà il numero effettivo di record rimanenti.

Il valore `GetRecordCount` di un recordset di tipo snapshot non è influenzato dalle modifiche nelle tabelle sottostanti.

Il valore `GetRecordCount` di un recordset di tipo tabella riflette il numero approssimativo di record nella tabella e viene influenzato immediatamente quando i record della tabella vengono aggiunti ed eliminati.

Un recordset senza record restituisce il valore 0. Quando si lavora con tabelle `GetRecordCount` collegate o database ODBC, restituisce sempre - 1. La `Requery` chiamata alla funzione membro su `GetRecordCount` un recordset reimposta il valore di come se la query fosse stata rieseguita.

Per informazioni correlate, vedere l'argomento "Proprietà RecordCount" nella Guida di DAO.

## <a name="cdaorecordsetgetsql"></a><a name="getsql"></a>CDaoRecordset::GetSQL

Chiamare questa funzione membro per ottenere l'istruzione SQL utilizzata per selezionare i record del recordset quando è stato aperto.

```
CString GetSQL() const;
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` che contiene l'istruzione SQL.

### <a name="remarks"></a>Osservazioni

Si tratta in genere di un'istruzione SQL **SELECT.**

La stringa restituita da `GetSQL` è in genere diversa da qualsiasi stringa passata al recordset nel parametro *lpszSQL* alla funzione membro [Open.](#open) Questo avviene perché il recordset costruisce un'istruzione `Open`SQL completa basata su ciò che è stato passato a , ciò che è stato specificato con ClassWizard e ciò che è possibile specificare nei [m_strFilter](#m_strfilter) e [m_strSort](#m_strsort) membri dati.

> [!NOTE]
> Chiamare questa funzione membro `Open`solo dopo aver chiamato .

Per informazioni correlate, vedere l'argomento "Proprietà SQL" nella Guida in linea di DAO.

## <a name="cdaorecordsetgettype"></a><a name="gettype"></a>CDaoRecordset::GetType

Chiamare questa funzione membro dopo aver aperto il recordset per determinare il tipo dell'oggetto recordset.

```
short GetType();
```

### <a name="return-value"></a>Valore restituito

Uno dei seguenti valori che indica il tipo di un recordset:

- `dbOpenTable`Recordset di tipo tabella

- `dbOpenDynaset`Recordset di tipo Dynaset

- `dbOpenSnapshot`Recordset di tipo snapshot

### <a name="remarks"></a>Osservazioni

Per informazioni correlate, vedere l'argomento "Proprietà Type" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetvalidationrule"></a><a name="getvalidationrule"></a>CDaoRecordset::GetValidationRule

Chiamare questa funzione membro per determinare la regola utilizzata per convalidare i dati.

```
CString GetValidationRule();
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` contenente un valore che convalida i dati in un record quando viene modificato o aggiunto a una tabella.

### <a name="remarks"></a>Osservazioni

Questa regola è basata su testo e viene applicata ogni volta che viene modificata la tabella sottostante. Se i dati non sono legali, MFC genera un'eccezione. Il messaggio di errore restituito è il testo della proprietà ValidationText dell'oggetto campo sottostante, se specificato, o il testo dell'espressione specificata dalla proprietà ValidationRule dell'oggetto campo sottostante. È possibile chiamare [GetValidationText](#getvalidationtext) per ottenere il testo del messaggio di errore.

Ad esempio, un campo in un record che richiede il giorno del mese potrebbe avere una regola di convalida come "GIORNO BETWEEN 1 And 31".

Per informazioni correlate, vedere l'argomento "Proprietà ValidationRule" nella Guida in linea di DAO.

## <a name="cdaorecordsetgetvalidationtext"></a><a name="getvalidationtext"></a>CDaoRecordset::GetValidationText

Chiamare questa funzione membro per recuperare il testo della proprietà ValidationText dell'oggetto campo sottostante.

```
CString GetValidationText();
```

### <a name="return-value"></a>Valore restituito

Oggetto `CString` contenente il testo del messaggio visualizzato se il valore di un campo non soddisfa la regola di convalida dell'oggetto campo sottostante.

### <a name="remarks"></a>Osservazioni

Per informazioni correlate, vedere l'argomento "Proprietà ValidationText" nella Guida in linea di DAO.

## <a name="cdaorecordsetisbof"></a><a name="isbof"></a>CDaoRecordset::IsBOF

Chiamare questa funzione membro prima di scorrere da un record all'altro per sapere se si è passati prima del primo record del recordset.

```
BOOL IsBOF() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il recordset non contiene record o se è stato eseguito lo scorrimento all'indietro prima del primo record; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

È inoltre `IsBOF` possibile `IsEOF` chiamare con per determinare se il recordset contiene record o è vuoto. Immediatamente dopo `Open`aver chiamato , se `IsBOF` il recordset non contiene record, restituisce un valore diverso da zero. Quando si apre un recordset che dispone di almeno un `IsBOF` record, il primo record è il record corrente e restituisce 0.

Se il primo record è il `MovePrev` `IsBOF` record corrente e si chiama , verrà successivamente restituito diverso da zero. Se `IsBOF` restituisce un `MovePrev`valore diverso da zero e si chiama , viene generata un'eccezione. Se `IsBOF` restituisce un valore diverso da zero, il record corrente non è definito e qualsiasi azione che richiede un record corrente genererà un'eccezione.

Effetto di metodi `IsBOF` `IsEOF` e impostazioni specifici:

- La `Open*` chiamata interna rende il primo record del `MoveFirst`recordset il record corrente chiamando . Pertanto, `Open` la chiamata su `IsBOF` un `IsEOF` set vuoto di record causa e per restituire diverso da zero. (Vedere la tabella seguente per `MoveFirst` il `MoveLast` comportamento di un errore o chiamata.)

- Tutte le operazioni di spostamento `IsBOF` che `IsEOF` individuano correttamente un record causano sia e restituire 0.

- Una `AddNew` chiamata seguita `Update` da una chiamata che inserisce correttamente un nuovo record causerà `IsBOF` il risultato 0, ma solo se `IsEOF` è già diverso da zero. Lo stato `IsEOF` di rimarrà sempre invariato. Come definito dal modulo di gestione di database Microsoft Jet, il puntatore del record corrente di un recordset vuoto si trova alla fine di un file, pertanto qualsiasi nuovo record viene inserito dopo il record corrente.

- Qualsiasi `Delete` chiamata, anche se rimuove l'unico record rimanente da `IsBOF` `IsEOF`un recordset, non modificherà il valore di o .

Questa tabella mostra quali operazioni di spostamento `IsBOF` /  `IsEOF`sono consentite con diverse combinazioni di .

||MoveFirst, MoveLast|MovePrev,<br /><br /> Sposta < 0|Sposta 0|Movenext<br /><br /> Sposta > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`Diverso da zero,<br /><br /> `IsEOF`=0|Consentito|Eccezione|Eccezione|Consentito|
|`IsBOF`=0,<br /><br /> `IsEOF`: diverso da zero|Consentito|Consentito|Eccezione|Eccezione|
|Entrambi diversi da zero|Eccezione|Eccezione|Eccezione|Eccezione|
|Entrambi 0|Consentito|Consentito|Consentito|Consentito|

Consentire un'operazione di spostamento non significa che l'operazione verrà individuata correttamente un record. Indica semplicemente che un tentativo di eseguire l'operazione Move specificata è consentito e non genererà un'eccezione. Il valore `IsBOF` delle `IsEOF` funzioni membro e può cambiare in seguito al tentativo di spostamento.

L'effetto delle operazioni di spostamento che non `IsBOF` `IsEOF` individuano un record sul valore e sulle impostazioni è illustrato nella tabella seguente.

||IsBOF|L'ISEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Diverso da zero|Diverso da zero|
|`Move` 0|Nessuna modifica|Nessuna modifica|
|`MovePrev`, `Move` < 0|Diverso da zero|Nessuna modifica|
|`MoveNext`, `Move` > 0|Nessuna modifica|Diverso da zero|

Per informazioni correlate, vedere l'argomento "Proprietà BOF, EOF" nella Guida in linea di DAO.

## <a name="cdaorecordsetisdeleted"></a><a name="isdeleted"></a>CDaoRecordset::IsDeleted

Chiamare questa funzione membro per determinare se il record corrente è stato eliminato.

```
BOOL IsDeleted() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il recordset è posizionato su un record eliminato; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Se si scorre su `IsDeleted` un record e restituisce TRUE (diverso da zero), è necessario eseguire lo scorrimento su un altro record prima di poter eseguire qualsiasi altra operazione del recordset.

> [!NOTE]
> Non è necessario controllare lo stato eliminato per i record in uno snapshot o un recordset di tipo tabella. Poiché i record non possono essere eliminati `IsDeleted`da uno snapshot, non è necessario chiamare . Per i recordset di tipo tabella, i record eliminati vengono effettivamente rimossi dal recordset. Una volta che un record è stato eliminato, da te, da un altro utente o da un altro recordset, non è possibile scorrere di nuovo fino a quel record. Pertanto, non è `IsDeleted`necessario chiamare .

Quando si elimina un record da un dynaset, questo viene rimosso dal recordset e non è possibile scorrere nuovamente tale record. Tuttavia, se un record in un dynaset viene eliminato da un `IsDeleted` altro utente o in un altro recordset basato sulla stessa tabella, restituirà TRUE quando si scorre successivamente a tale record.

Per informazioni correlate, vedere gli argomenti "Metodo Delete", "Proprietà LastModified" e "Proprietà EditMode" nella Guida in linea di DAO.

## <a name="cdaorecordsetiseof"></a><a name="iseof"></a>CDaoRecordset::IsEOF

Chiamare questa funzione membro mentre si scorre da un record all'altro per scoprire se si è andati oltre l'ultimo record del recordset.

```
BOOL IsEOF() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se il recordset non contiene record o se è stato eseguito lo scorrimento oltre l'ultimo record; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

È inoltre `IsEOF` possibile chiamare per determinare se il recordset contiene record o è vuoto. Immediatamente dopo `Open`aver chiamato , se `IsEOF` il recordset non contiene record, restituisce un valore diverso da zero. Quando si apre un recordset che dispone di almeno un `IsEOF` record, il primo record è il record corrente e restituisce 0.

Se l'ultimo record è il `MoveNext` `IsEOF` record corrente quando si chiama , verrà successivamente restituito diverso da zero. Se `IsEOF` restituisce un `MoveNext`valore diverso da zero e si chiama , viene generata un'eccezione. Se `IsEOF` restituisce un valore diverso da zero, il record corrente non è definito e qualsiasi azione che richiede un record corrente genererà un'eccezione.

Effetto di metodi `IsBOF` `IsEOF` e impostazioni specifici:

- La `Open` chiamata interna rende il primo record del `MoveFirst`recordset il record corrente chiamando . Pertanto, `Open` la chiamata su `IsBOF` un `IsEOF` set vuoto di record causa e per restituire diverso da zero. Vedere la tabella seguente per il `MoveFirst` comportamento di una chiamata non riuscita.

- Tutte le operazioni di spostamento `IsBOF` che `IsEOF` individuano correttamente un record causano sia e restituire 0.

- Una `AddNew` chiamata seguita `Update` da una chiamata che inserisce correttamente un nuovo record causerà `IsBOF` il risultato 0, ma solo se `IsEOF` è già diverso da zero. Lo stato `IsEOF` di rimarrà sempre invariato. Come definito dal modulo di gestione di database Microsoft Jet, il puntatore del record corrente di un recordset vuoto si trova alla fine di un file, pertanto qualsiasi nuovo record viene inserito dopo il record corrente.

- Qualsiasi `Delete` chiamata, anche se rimuove l'unico record rimanente da `IsBOF` `IsEOF`un recordset, non modificherà il valore di o .

Questa tabella mostra quali operazioni di spostamento `IsBOF` /  `IsEOF`sono consentite con diverse combinazioni di .

||MoveFirst, MoveLast|MovePrev,<br /><br /> Sposta < 0|Sposta 0|Movenext<br /><br /> Sposta > 0|
|------|-------------------------|-----------------------------|------------|-----------------------------|
|`IsBOF`Diverso da zero,<br /><br /> `IsEOF`=0|Consentito|Eccezione|Eccezione|Consentito|
|`IsBOF`=0,<br /><br /> `IsEOF`: diverso da zero|Consentito|Consentito|Eccezione|Eccezione|
|Entrambi diversi da zero|Eccezione|Eccezione|Eccezione|Eccezione|
|Entrambi 0|Consentito|Consentito|Consentito|Consentito|

Consentire un'operazione di spostamento non significa che l'operazione verrà individuata correttamente un record. Indica semplicemente che un tentativo di eseguire l'operazione Move specificata è consentito e non genererà un'eccezione. Il valore `IsBOF` delle `IsEOF` funzioni membro e può cambiare in seguito al tentativo di spostamento.

L'effetto delle operazioni di spostamento che non `IsBOF` `IsEOF` individuano un record sul valore e sulle impostazioni è illustrato nella tabella seguente.

||IsBOF|L'ISEOF|
|------|-----------|-----------|
|`MoveFirst`, `MoveLast`|Diverso da zero|Diverso da zero|
|`Move` 0|Nessuna modifica|Nessuna modifica|
|`MovePrev`, `Move` < 0|Diverso da zero|Nessuna modifica|
|`MoveNext`, `Move` > 0|Nessuna modifica|Diverso da zero|

Per informazioni correlate, vedere l'argomento "Proprietà BOF, EOF" nella Guida in linea di DAO.

## <a name="cdaorecordsetisfielddirty"></a><a name="isfielddirty"></a>CDaoRecordset::IsFieldDirty

Chiamare questa funzione membro per determinare se il membro dati di campo specificato di un dynaset è stato contrassegnato come "dirty" (modificato).

```
BOOL IsFieldDirty(void* pv);
```

### <a name="parameters"></a>Parametri

*Pv*<br/>
Puntatore al membro dati di campo di cui si desidera controllare lo stato oppure NULL per determinare se uno dei campi è dirty.

### <a name="return-value"></a>Valore restituito

Diverso da zero se il membro dati di campo specificato è contrassegnato come dirty; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

I dati in tutti i membri dati di campo dirty verranno trasferiti al record `Update` nell'origine `CDaoRecordset` dati quando `Edit` il `AddNew`record corrente viene aggiornato da una chiamata alla funzione membro di (dopo una chiamata a o ). Con questa conoscenza, è possibile eseguire ulteriori passaggi, ad esempio l'annullamento del flag del membro dati di campo per contrassegnare la colonna in modo che non venga scritta nell'origine dati.

`IsFieldDirty`viene implementato `DoFieldExchange`tramite .

## <a name="cdaorecordsetisfieldnull"></a><a name="isfieldnull"></a>CDaoRecordset::IsFieldNull

Chiamare questa funzione membro per determinare se il membro dati di campo specificato di un recordset è stato contrassegnato come Null.

```
BOOL IsFieldNull(void* pv);
```

### <a name="parameters"></a>Parametri

*Pv*<br/>
Puntatore al membro dati di campo di cui si desidera controllare lo stato oppure NULL per determinare se uno dei campi è Null.

### <a name="return-value"></a>Valore restituito

Diverso da zero se il membro dati di campo specificato è contrassegnato come Null; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

(Nella terminologia del database, Null significa "non avere alcun valore" e non è uguale a NULL in C . Se un membro dati di campo è contrassegnato come Null, viene interpretato come una colonna del record corrente per cui non è presente alcun valore.

> [!NOTE]
> In alcune situazioni, l'uso può essere inefficiente, come illustrato nell'esempio di codice seguente:In certain situations, using `IsFieldNull` can be inefficient, as the following code example illustrates:

[!code-cpp[NVC_MFCDatabase#5](../../mfc/codesnippet/cpp/cdaorecordset-class_5.cpp)]

> [!NOTE]
> Se si utilizza l'associazione di `CDaoRecordset`record dinamica, senza derivare da , assicurarsi di utilizzare VT_NULL come illustrato nell'esempio.

## <a name="cdaorecordsetisfieldnullable"></a><a name="isfieldnullable"></a>CDaoRecordset::IsFieldNullable

Chiamare questa funzione membro per determinare se il membro dati di campo specificato è "nullable" (può essere impostato su un Null valore; NULL c'è valore non è uguale a Null, che, nella terminologia del database, significa "non avere alcun valore").

```
BOOL IsFieldNullable(void* pv);
```

### <a name="parameters"></a>Parametri

*Pv*<br/>
Puntatore al membro dati di campo di cui si desidera controllare lo stato oppure NULL per determinare se uno dei campi è Null.

### <a name="return-value"></a>Valore restituito

Diverso da zero se il membro dati di campo specificato può essere reso Null; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Un campo che non può essere Null deve avere un valore. Se si tenta di impostare un campo di questo tipo su Null durante l'aggiunta o l'aggiornamento di un record, l'origine dati rifiuta l'aggiunta o l'aggiornamento e `Update` genererà un'eccezione. L'eccezione si `Update`verifica quando `SetFieldNull`si chiama , non quando si chiama .

## <a name="cdaorecordsetisopen"></a><a name="isopen"></a>CDaoRecordset::IsOpen

Chiamare questa funzione membro per determinare se il recordset è aperto.

```
BOOL IsOpen() const;
```

### <a name="return-value"></a>Valore restituito

Diverso da zero se `Open` l'oggetto recordset o `Requery` la funzione membro è stata chiamata in precedenza e il recordset non è stato chiuso; in caso contrario 0.

### <a name="remarks"></a>Osservazioni

## <a name="cdaorecordsetm_bcheckcachefordirtyfields"></a><a name="m_bcheckcachefordirtyfields"></a>CDaoRecordset::m_bCheckCacheForDirtyFields

Contiene un flag che indica se i campi memorizzati nella cache vengono contrassegnati automaticamente come dirty (modificati) e Null.

### <a name="remarks"></a>Osservazioni

Il flag predefinito è TRUE. L'impostazione in questo membro dati controlla l'intero meccanismo di doppio buffering. Se si imposta il flag su TRUE, è possibile disattivare la memorizzazione nella cache campo per campo utilizzando il meccanismo DFX. Se si imposta il flag su `SetFieldDirty` `SetFieldNull` FALSE, è necessario chiamare e se stessi.

Impostare questo membro `Open`dati prima di chiamare . Questo meccanismo è principalmente per facilità d'uso. Le prestazioni potrebbero essere più lente a causa del doppio buffer dei campi quando vengono apportate modifiche.

## <a name="cdaorecordsetm_nfields"></a><a name="m_nfields"></a>CDaoRecordset::m_nFields

Contiene il numero di membri dati di campo nella classe recordset e il numero di colonne selezionate dal recordset dall'origine dati.

### <a name="remarks"></a>Osservazioni

Il costruttore per la `m_nFields` classe recordset deve essere inizializzato con il numero corretto di campi associati in modo statico. ClassWizard scrive automaticamente questa inizializzazione quando viene utilizzata per dichiarare la classe del recordset. È anche possibile scriverlo manualmente.

Il framework utilizza questo numero per gestire l'interazione tra i membri dati di campo e le colonne corrispondenti del record corrente nell'origine dati.

> [!NOTE]
> Questo numero deve corrispondere al numero `DoFieldExchange` di colonne `SetFieldType` di output `CDaoFieldExchange::outputColumn`registrate in dopo una chiamata a con il parametro .

È possibile associare le `CDaoRecordset::GetFieldValue` `CDaoRecordset::SetFieldValue`colonne in modo dinamico tramite e . In questo caso, non è necessario incrementare il conteggio in `m_nFields` per riflettere `DoFieldExchange` il numero di chiamate di funzione DFX nella funzione membro.

## <a name="cdaorecordsetm_nparams"></a><a name="m_nparams"></a>CDaoRecordset::m_nParams

Contiene il numero di membri dati di parametro nella classe recordset, ovvero il numero di parametri passati con la query del recordset.

### <a name="remarks"></a>Osservazioni

Se la classe recordset dispone di membri dati di parametro, il costruttore della classe deve inizializzare *m_nParams* con il numero corretto. Il valore di *m_nParams* il valore predefinito è 0. Se si aggiungono membri dati di parametro, operazione che è necessario eseguire manualmente, è necessario aggiungere manualmente un'inizializzazione nel costruttore della classe per riflettere il numero di parametri (che deve essere grande almeno quanto il numero di segnaposto '' nella *stringa m_strFilter* o *m_strSort).*

Il framework utilizza questo numero quando parametrizza la query del recordset.

> [!NOTE]
> Questo numero deve corrispondere al numero di `DoFieldExchange` "param" `SetFieldType` registrati dopo `CFieldExchange::param`una chiamata a con il parametro .

Per informazioni correlate, vedere l'argomento "Oggetto parametro" nella Guida in linea di DAO.

## <a name="cdaorecordsetm_pdaorecordset"></a><a name="m_pdaorecordset"></a>CDaoRecordset::m_pDAORecordset

Contiene un puntatore all'interfaccia OLE per `CDaoRecordset` l'oggetto recordset DAO sottostante l'oggetto.

### <a name="remarks"></a>Osservazioni

Utilizzare questo puntatore se è necessario accedere direttamente all'interfaccia DAO.

Per informazioni correlate, vedere l'argomento "Oggetto Recordset" nella Guida in linea di DAO.

## <a name="cdaorecordsetm_pdatabase"></a><a name="m_pdatabase"></a>CDaoRecordset::m_pDatabase

Contiene un puntatore all'oggetto tramite il `CDaoDatabase` quale il recordset è connesso a un'origine dati.

### <a name="remarks"></a>Osservazioni

Questa variabile viene impostata in due modi. In genere, si passa un `CDaoDatabase` puntatore a un oggetto già aperto quando si costruisce l'oggetto recordset. Se invece passi `CDaoRecordset` NULL, crea un `CDaoDatabase` oggetto e lo apre. In entrambi `CDaoRecordset` i casi, archivia il puntatore in questa variabile.

In genere non è necessario utilizzare `m_pDatabase`direttamente il puntatore memorizzato in . Se si scrivono `CDaoRecordset`estensioni personalizzate in , tuttavia, potrebbe essere necessario utilizzare il puntatore. Ad esempio, potrebbe essere necessario il `CDaoException`puntatore se si genera il proprio (s).

Per informazioni correlate, vedere l'argomento "Oggetto Database" nella Guida in linea di DAO.

## <a name="cdaorecordsetm_strfilter"></a><a name="m_strfilter"></a>CDaoRecordset::m_strFilter

Contiene una stringa utilizzata per costruire la clausola **WHERE** di un'istruzione SQL.

### <a name="remarks"></a>Osservazioni

Non include la parola riservata **WHERE** per filtrare il recordset. L'utilizzo di questo membro dati non è applicabile ai recordset di tipo tabella. L'utilizzo `m_strFilter` di non ha alcun `CDaoQueryDef` effetto quando si apre un recordset utilizzando un puntatore.

Utilizzare il formato di data statunitense (mese-giorno-anno) quando si filtrano i campi contenenti date, anche se non si utilizza la versione statunitense del modulo di gestione di database Microsoft Jet. in caso contrario, i dati potrebbero non essere filtrati come previsto.

Per informazioni correlate, vedere l'argomento "Proprietà Filter" nella Guida in linea di DAO.

## <a name="cdaorecordsetm_strsort"></a><a name="m_strsort"></a>CDaoRecordset::m_strSort

Contiene una stringa contenente la clausola **ORDERBY** di un'istruzione SQL senza le parole riservate **ORDERBY**.

### <a name="remarks"></a>Osservazioni

È possibile eseguire l'ordinamento in base a oggetti recordset di tipo dynaset e snapshot.

Non è possibile ordinare gli oggetti recordset di tipo tabella. Per determinare l'ordinamento di un recordset di tipo tabella, chiamare [SetCurrentIndex](#setcurrentindex).

L'utilizzo di *m_strSort* non ha alcun `CDaoQueryDef` effetto quando si apre un recordset utilizzando un puntatore.

Per informazioni correlate, vedere l'argomento "Proprietà Sort" nella Guida in linea di DAO.

## <a name="cdaorecordsetmove"></a><a name="move"></a>CDaoRecordset::Sposta

Chiamare questa funzione membro per posizionare i record *lRows* del recordset dal record corrente.

```
virtual void Move(long lRows);
```

### <a name="parameters"></a>Parametri

*lRows (file)*<br/>
Numero di record da spostare in avanti o indietro. I valori positivi si spostano in avanti verso la fine del recordset. I valori negativi si spostano all'indietro, verso l'inizio.

### <a name="remarks"></a>Osservazioni

È possibile spostarsi in avanti o indietro. `Move( 1 )`equivale a `MoveNext`, `Move( -1 )` ed `MovePrev`è equivalente a .

> [!CAUTION]
> La chiamata `Move` a una delle funzioni genera un'eccezione se il recordset non contiene record. In generale, `IsBOF` chiamare `IsEOF` entrambi e prima di un Move operazione per determinare se il recordset dispone di record. Dopo aver `Open` `Requery`chiamato o `IsBOF` `IsEOF`, chiamare o .

> [!NOTE]
> Se è stato eseguito lo scorrimento oltre `IsBOF` `IsEOF` l'inizio o la `Move` fine `CDaoException`del recordset ( o viene restituito da un valore diverso da zero), viene generata una chiamata a .

> [!NOTE]
> Se si chiama `Move` una delle funzioni durante l'aggiornamento o l'aggiunta del record corrente, gli aggiornamenti andranno persi senza alcun avviso.

Quando si `Move` chiama uno snapshot a scorrimento forward-only, il parametro *lRows* deve essere un numero intero positivo e i segnalibri non sono consentiti, pertanto è possibile spostarsi solo in avanti.

Per impostare il primo, l'ultimo, il successivo o `MoveFirst`il `MoveLast` `MoveNext`precedente `MovePrev` record di un recordset come record corrente, chiamare la funzione membro , , o .

Per informazioni correlate, vedere gli argomenti "Metodo Move" e "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetmovefirst"></a><a name="movefirst"></a>CDaoRecordset::MoveFirst

Chiamare questa funzione membro per rendere il primo record nel recordset (se presente) il record corrente.

```
void MoveFirst();
```

### <a name="remarks"></a>Osservazioni

Non è necessario `MoveFirst` chiamare immediatamente dopo l'apertura del recordset. A quel punto, il primo record (se presente) è automaticamente il record corrente.

> [!CAUTION]
> La chiamata `Move` a una delle funzioni genera un'eccezione se il recordset non contiene record. In generale, `IsBOF` chiamare `IsEOF` entrambi e prima di un Move operazione per determinare se il recordset dispone di record. Dopo aver `Open` `Requery`chiamato o `IsBOF` `IsEOF`, chiamare o .

> [!NOTE]
> Se si chiama `Move` una delle funzioni durante l'aggiornamento o l'aggiunta del record corrente, gli aggiornamenti andranno persi senza alcun avviso.

Utilizzare `Move` le funzioni per passare da un record all'altro senza applicare una condizione. Utilizzare le operazioni Find per individuare i record in un oggetto recordset di tipo dynaset o snapshot che soddisfano una determinata condizione. Per individuare un record in un oggetto `Seek`recordset di tipo tabella, chiamare .

Se il recordset fa riferimento a un recordset di tipo tabella, lo spostamento segue l'indice corrente della tabella. È possibile impostare l'indice corrente utilizzando la proprietà Index dell'oggetto DAO sottostante. Se non si imposta l'indice corrente, l'ordine dei record restituiti non è definito.

Se si `MoveLast` chiama su un oggetto recordset basato su una query SQL o querydef, la query viene forzata al completamento e l'oggetto recordset viene popolato completamente.

Non è `MoveFirst` possibile `MovePrev` chiamare la funzione membro o con uno snapshot a scorrimento forward-only.

Per spostare la posizione del record corrente in un oggetto recordset `Move`di un numero specifico di record in avanti o indietro, chiamare .

Per informazioni correlate, vedere gli argomenti "Metodo Move" e "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetmovelast"></a><a name="movelast"></a>CDaoRecordset::MoveLast

Chiamare questa funzione membro per rendere l'ultimo record (se presente) nel recordset il record corrente.

```
void MoveLast();
```

### <a name="remarks"></a>Osservazioni

> [!CAUTION]
> La chiamata `Move` a una delle funzioni genera un'eccezione se il recordset non contiene record. In generale, `IsBOF` chiamare `IsEOF` entrambi e prima di un Move operazione per determinare se il recordset dispone di record. Dopo aver `Open` `Requery`chiamato o `IsBOF` `IsEOF`, chiamare o .

> [!NOTE]
> Se si chiama `Move` una delle funzioni durante l'aggiornamento o l'aggiunta del record corrente, gli aggiornamenti andranno persi senza alcun avviso.

Utilizzare `Move` le funzioni per passare da un record all'altro senza applicare una condizione. Utilizzare le operazioni Find per individuare i record in un oggetto recordset di tipo dynaset o snapshot che soddisfano una determinata condizione. Per individuare un record in un oggetto `Seek`recordset di tipo tabella, chiamare .

Se il recordset fa riferimento a un recordset di tipo tabella, lo spostamento segue l'indice corrente della tabella. È possibile impostare l'indice corrente utilizzando la proprietà Index dell'oggetto DAO sottostante. Se non si imposta l'indice corrente, l'ordine dei record restituiti non è definito.

Se si `MoveLast` chiama su un oggetto recordset basato su una query SQL o querydef, la query viene forzata al completamento e l'oggetto recordset viene popolato completamente.

Per spostare la posizione del record corrente in un oggetto recordset `Move`di un numero specifico di record in avanti o indietro, chiamare .

Per informazioni correlate, vedere gli argomenti "Metodo Move" e "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetmovenext"></a><a name="movenext"></a>CDaoRecordset::MoveNext

Chiamare questa funzione membro per rendere il record successivo nel recordset il record corrente.

```
void MoveNext();
```

### <a name="remarks"></a>Osservazioni

Si consiglia di `IsBOF` chiamare prima di tentare di passare al record precedente. Una chiamata `MovePrev` a `CDaoException` genererà un if `IsBOF` restituisce un valore diverso da zero, che indica che è già stato eseguito lo scorrimento prima del primo record o che nessun record è stato selezionato dal recordset.

> [!CAUTION]
> La chiamata `Move` a una delle funzioni genera un'eccezione se il recordset non contiene record. In generale, `IsBOF` chiamare `IsEOF` entrambi e prima di un Move operazione per determinare se il recordset dispone di record. Dopo aver `Open` `Requery`chiamato o `IsBOF` `IsEOF`, chiamare o .

> [!NOTE]
> Se si chiama `Move` una delle funzioni durante l'aggiornamento o l'aggiunta del record corrente, gli aggiornamenti andranno persi senza alcun avviso.

Utilizzare `Move` le funzioni per passare da un record all'altro senza applicare una condizione. Utilizzare le operazioni Find per individuare i record in un oggetto recordset di tipo dynaset o snapshot che soddisfano una determinata condizione. Per individuare un record in un oggetto `Seek`recordset di tipo tabella, chiamare .

Se il recordset fa riferimento a un recordset di tipo tabella, lo spostamento segue l'indice corrente della tabella. È possibile impostare l'indice corrente utilizzando la proprietà Index dell'oggetto DAO sottostante. Se non si imposta l'indice corrente, l'ordine dei record restituiti non è definito.

Per spostare la posizione del record corrente in un oggetto recordset `Move`di un numero specifico di record in avanti o indietro, chiamare .

Per informazioni correlate, vedere gli argomenti "Metodo Move" e "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetmoveprev"></a><a name="moveprev"></a>CDaoRecordset::MovePrev

Chiamare questa funzione membro per rendere il record precedente nel recordset il record corrente.

```
void MovePrev();
```

### <a name="remarks"></a>Osservazioni

Si consiglia di `IsBOF` chiamare prima di tentare di passare al record precedente. Una chiamata `MovePrev` a `CDaoException` genererà un if `IsBOF` restituisce un valore diverso da zero, che indica che è già stato eseguito lo scorrimento prima del primo record o che nessun record è stato selezionato dal recordset.

> [!CAUTION]
> La chiamata `Move` a una delle funzioni genera un'eccezione se il recordset non contiene record. In generale, `IsBOF` chiamare `IsEOF` entrambi e prima di un Move operazione per determinare se il recordset dispone di record. Dopo aver `Open` `Requery`chiamato o `IsBOF` `IsEOF`, chiamare o .

> [!NOTE]
> Se si chiama `Move` una delle funzioni durante l'aggiornamento o l'aggiunta del record corrente, gli aggiornamenti andranno persi senza alcun avviso.

Utilizzare `Move` le funzioni per passare da un record all'altro senza applicare una condizione. Utilizzare le operazioni Find per individuare i record in un oggetto recordset di tipo dynaset o snapshot che soddisfano una determinata condizione. Per individuare un record in un oggetto `Seek`recordset di tipo tabella, chiamare .

Se il recordset fa riferimento a un recordset di tipo tabella, lo spostamento segue l'indice corrente della tabella. È possibile impostare l'indice corrente utilizzando la proprietà Index dell'oggetto DAO sottostante. Se non si imposta l'indice corrente, l'ordine dei record restituiti non è definito.

Non è `MoveFirst` possibile `MovePrev` chiamare la funzione membro o con uno snapshot a scorrimento forward-only.

Per spostare la posizione del record corrente in un oggetto recordset `Move`di un numero specifico di record in avanti o indietro, chiamare .

Per informazioni correlate, vedere gli argomenti "Metodo Move" e "MoveFirst, MoveLast, MoveNext, MovePrevious Methods" nella Guida in linea di DAO.

## <a name="cdaorecordsetopen"></a><a name="open"></a>CDaoRecordset::Open

È necessario chiamare questa funzione membro per recuperare i record per il recordset.

```
virtual void Open(
    int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
    LPCTSTR lpszSQL = NULL,
    int nOptions = 0);

virtual void Open(
    CDaoTableDef* pTableDef,
    int nOpenType = dbOpenTable,
    int nOptions = 0);

virtual void Open(
    CDaoQueryDef* pQueryDef,
    int nOpenType = dbOpenDynaset,
    int nOptions = 0);
```

### <a name="parameters"></a>Parametri

*nApriTipo*<br/>
Uno dei valori seguenti:

- `dbOpenDynaset`Recordset di tipo dynaset con scorrimento bidirezionale. Questa è la modalità predefinita.

- `dbOpenTable`Recordset di tipo tabella con scorrimento bidirezionale.

- `dbOpenSnapshot`Recordset di tipo snapshot con scorrimento bidirezionale.

*lpszSQL (informazioni in lingua inglese)*<br/>
Puntatore di stringa contenente uno degli elementi seguenti:

- Puntatore NULL.

- Il nome di uno o più tabledef e/o querydef (separati da virgole).

- Un'istruzione SQL **SELECT** (facoltativamente con una clausola SQL **WHERE** o **ORDERBY).**

- Query pass-through.

*nOpzioni*<br/>
Una o più delle opzioni elencate di seguito. Il valore predefinito è 0. Sono disponibili i valori seguenti:

- `dbAppendOnly`È possibile accodare solo nuovi record (solo recordset di tipo dynaset). Questa opzione significa letteralmente che i record possono essere solo aggiunti. Le classi di database ODBC MFC dispongono di un'opzione di solo accodamento che consente di recuperare e aggiungere i record.

- `dbForwardOnly`Il recordset è uno snapshot a scorrimento forward-only.

- `dbSeeChanges`Generare un'eccezione se un altro utente sta modificando i dati che si stanno modificando.

- `dbDenyWrite`Gli altri utenti non possono modificare o aggiungere record.

- `dbDenyRead`Gli altri utenti non possono visualizzare i record (solo recordset di tipo tabella).

- `dbReadOnly`È possibile visualizzare solo i record; altri utenti possono modificarli.

- `dbInconsistent`Sono consentiti aggiornamenti incoerenti (solo recordset di tipo dynaset).

- `dbConsistent`Sono consentiti solo aggiornamenti coerenti (solo recordset di tipo dynaset).

> [!NOTE]
> Le costanti `dbConsistent` `dbInconsistent` e si escludono a vicenda. È possibile utilizzare uno o l'altro, ma `Open`non entrambi in una determinata istanza di .

*pTableDef (informazioni in stato instato di un*<br/>
Puntatore a un oggetto [CDaoTableDef.](../../mfc/reference/cdaotabledef-class.md) Questa versione è valida solo per i recordset di tipo tabella. Quando si utilizza `CDaoDatabase` questa opzione, `CDaoRecordset` il puntatore utilizzato per costruire l'oggetto non viene utilizzato; viene invece utilizzato il database in cui risiede il tabledef.

*pQueryDef (informazioni in stato instato di base*<br/>
Puntatore a un oggetto [CDaoQueryDef.](../../mfc/reference/cdaoquerydef-class.md) Questa versione è valida solo per i recordset di tipo dynaset e di tipo snapshot. Quando si utilizza `CDaoDatabase` questa opzione, `CDaoRecordset` il puntatore utilizzato per costruire l'oggetto non viene utilizzato; viene invece utilizzato il database in cui risiede il querydef.

### <a name="remarks"></a>Osservazioni

Prima `Open`di chiamare , è necessario costruire l'oggetto recordset. Sono disponibili diversi modi per eseguire questa operazione:

- Quando si costruisce l'oggetto recordset, `CDaoDatabase` passare un puntatore a un oggetto che è già aperto.

- Quando si costruisce l'oggetto recordset, `CDaoDatabase` passare un puntatore a un oggetto che non è aperto. Il recordset `CDaoDatabase` apre un oggetto, ma non lo chiude alla chiusura dell'oggetto recordset.

- Quando si costruisce l'oggetto recordset, passare un puntatore NULL. Chiama l'oggetto recordset `GetDefaultDBName` per ottenere il nome di Microsoft Access. MDB da aprire. Il recordset apre `CDaoDatabase` quindi un oggetto e lo mantiene aperto finché il recordset è aperto. Quando si `Close` chiama il `CDaoDatabase` recordset, viene chiuso anche l'oggetto.

    > [!NOTE]
    >  Quando il recordset `CDaoDatabase` apre l'oggetto, apre l'origine dati con accesso non esclusivo.

Per la `Open` versione di che utilizza il *lpszSQL* parametro, una volta aperto il recordset è possibile recuperare i record in uno dei diversi modi. La prima opzione è quella di `DoFieldExchange`avere funzioni DFX nel file . La seconda opzione consiste nell'utilizzare `GetFieldValue` l'associazione dinamica chiamando la funzione membro. Queste opzioni possono essere implementate separatamente o in combinazione. Se vengono combinati, sarà necessario passare manualmente l'istruzione `Open`SQL nella chiamata a .

Quando si utilizza la `Open` seconda versione `CDaoTableDef` di dove si passa un oggetto, `DoFieldExchange` le colonne risultanti saranno disponibili per `GetFieldValue`l'associazione tramite e il meccanismo DFX e/o associare in modo dinamico tramite .

> [!NOTE]
> È possibile `Open` chiamare `CDaoTableDef` utilizzando un oggetto solo per i recordset di tipo tabella.

Quando si utilizza la `Open` terza versione `CDaoQueryDef` di dove si passa un oggetto, tale query verrà eseguita `DoFieldExchange` e le colonne risultanti saranno `GetFieldValue`disponibili per l'associazione tramite e il meccanismo DFX e/o associare in modo dinamico tramite .

> [!NOTE]
> È possibile `Open` chiamare `CDaoQueryDef` utilizzando un oggetto solo per recordset di tipo dynaset e di tipo snapshot.

Per la prima `Open` versione `lpszSQL` di che utilizza il parametro, i record vengono selezionati in base ai criteri illustrati nella tabella seguente.

|Valore del parametro `lpszSQL`|I record selezionati sono determinati da|Esempio|
|--------------------------------------|----------------------------------------|-------------|
|NULL|Stringa restituita da `GetDefaultSQL`.||
|Elenco delimitato da virgole di uno o più nomi tabledef e/o querydef.|Tutte le colonne `DoFieldExchange`rappresentate nel file .|`"Customer"`|
|**SELECT** elenco di colonne **FROM** table-list|Le colonne specificate dai tabledef e/o querydef specificati.|`"SELECT CustId, CustName`<br /><br /> `FROM Customer"`|

La procedura consueta `Open`consiste nel passare NULL a ; In tal `Open` caso, chiama , una `GetDefaultSQL`funzione membro sottoponibile a override generata da ClassWizard durante la creazione di una classe derivata da . `CDaoRecordset` Questo valore fornisce i nomi tabledef e/o querydef specificati in ClassWizard. È invece possibile specificare altre informazioni nel parametro *lpszSQL.*

Qualunque cosa `Open` si passi, costruisce una stringa SQL finale per la query (la stringa può avere SQL **WHERE** e **ORDERBY** clausole aggiunte alla stringa *lpszSQL* passato) e quindi esegue la query. È possibile esaminare la `GetSQL` stringa `Open`costruita chiamando dopo aver chiamato dopo aver chiamato .

I membri dei dati di campo della classe recordset sono associati alle colonne dei dati selezionati. Se vengono restituiti record, il primo di essi diventa il record corrente.

Se si desidera impostare le opzioni per il recordset, `m_strFilter` ad esempio un filtro o `Open`un ordinamento, impostare `m_strSort` o dopo aver creato l'oggetto recordset ma prima di chiamare . Se si desidera aggiornare i record nel recordset dopo `Requery`che il recordset è già aperto, chiamare .

Se si `Open` chiama su un recordset di tipo dynaset o snapshot o se l'origine dati fa riferimento a `dbOpenTable` un'istruzione SQL o a un tabledef che rappresenta una tabella associata, non è possibile utilizzare per l'argomento type. in caso contrario, MFC genera un'eccezione. Per determinare se un oggetto tabledef rappresenta una tabella associata, creare un oggetto [CDaoTableDef](../../mfc/reference/cdaotabledef-class.md) e chiamare la relativa funzione membro [GetConnect](../../mfc/reference/cdaotabledef-class.md#getconnect) .

Utilizzare `dbSeeChanges` il flag se si desidera intercettare le modifiche apportate da un altro utente o da un altro programma sul computer quando si modifica o si elimina lo stesso record. Ad esempio, se due utenti iniziano a modificare lo `Update` stesso record, il primo utente a chiamare la funzione membro ha esito positivo. Quando `Update` viene chiamato dal secondo `CDaoException` utente, viene generata un'eccezione. Analogamente, se il secondo `Delete` utente tenta di chiamare per eliminare il record `CDaoException` ed è già stato modificato dal primo utente, si verifica un oggetto .

In genere, se `CDaoException` l'utente ottiene questo durante l'aggiornamento, il codice deve aggiornare il contenuto dei campi e recuperare i valori appena modificati. Se l'eccezione si verifica durante il processo di eliminazione, il codice potrebbe visualizzare i dati del nuovo record all'utente e un messaggio che indica che i dati sono stati modificati di recente. A questo punto, il codice può richiedere una conferma che l'utente desidera comunque eliminare il record.

> [!TIP]
> Utilizzare l'opzione di scorrimento`dbForwardOnly`forward-only ( ) per migliorare le prestazioni quando l'applicazione esegue un singolo passaggio attraverso un recordset aperto da un'origine dati ODBC.

Per informazioni correlate, vedere l'argomento "Metodo OpenRecordset" nella Guida in linea di DAO.

## <a name="cdaorecordsetrequery"></a><a name="requery"></a>CDaoRecordset::Requery

Chiamare questa funzione membro per ricompilare (aggiornare) un recordset.

```
virtual void Requery();
```

### <a name="remarks"></a>Osservazioni

Se vengono restituiti record, il primo di essi diventa il record corrente.

Affinché il recordset rifletta le aggiunte e le eliminazioni che l'utente o altri `Requery`utenti effettuano all'origine dati, è necessario ricompilare il recordset chiamando . Se il recordset è un dynaset, riflette automaticamente gli aggiornamenti che l'utente o altri utenti apportano ai record esistenti (ma non alle aggiunte). Se il recordset è uno `Requery` snapshot, è necessario chiamare per riflettere le modifiche apportate da altri utenti, nonché le aggiunte e le eliminazioni.

Per un dynaset o uno `Requery` snapshot, chiamare ogni volta che si desidera ricompilare il recordset utilizzando i valori dei parametri. Impostare il nuovo filtro o ordinamento `Requery`impostando [m_strFilter](#m_strfilter) e [m_strSort](#m_strsort) prima di chiamare . Impostare nuovi parametri assegnando nuovi valori `Requery`ai membri dati di parametro prima di chiamare .

Se il tentativo di ricompilare il recordset ha esito negativo, il recordset viene chiuso. Prima di `Requery`chiamare , è possibile determinare se è possibile rieseguire la query del recordset chiamando la funzione membro [CanRestart](#canrestart) . `CanRestart`non garantisce `Requery` che avrà successo.

> [!CAUTION]
> Chiama `Requery` solo dopo `Open`aver chiamato .

> [!NOTE]
> La chiamata a [Requery](#requery) modifica i segnalibri DAO.

Non è possibile `Requery` chiamare un recordset di tipo dynaset `CanRestart` o snapshot se la chiamata restituisce 0, né è possibile utilizzarlo in un recordset di tipo tabella.

Se `IsBOF` entrambi `IsEOF` e restituiscono `Requery`un valore diverso da zero dopo la chiamata , la query non ha restituito alcun record e il recordset non conterrà dati.

Per informazioni correlate, vedere l'argomento "Metodo Requery" nella Guida in linea di DAO.

## <a name="cdaorecordsetseek"></a><a name="seek"></a>CDaoRecordset::Seek

Chiamare questa funzione membro per individuare il record in un oggetto recordset di tipo tabella indicizzato che soddisfa i criteri specificati per l'indice corrente e rendere tale record il record corrente.

```
BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKey1,
    COleVariant* pKey2 = NULL,
    COleVariant* pKey3 = NULL);

BOOL Seek(
    LPCTSTR lpszComparison,
    COleVariant* pKeyArray,
    WORD nKeys);
```

### <a name="parameters"></a>Parametri

*lpszConfronto*<br/>
Una delle seguenti espressioni stringa: "<", "",\<"", """, ">" o ">".

*pChiave1*<br/>
Puntatore a un [COleVariant](../../mfc/reference/colevariant-class.md) il cui valore corrisponde al primo campo nell'indice. Obbligatorio.

*pChiave2*<br/>
Puntatore a `COleVariant` un il cui valore corrisponde al secondo campo dell'indice, se presente. Il valore predefinito è NULL.

*pChiave3*<br/>
Puntatore a `COleVariant` un il cui valore corrisponde al terzo campo dell'indice, se presente. Il valore predefinito è NULL.

*pKeyArray (matrice di chiavi)*<br/>
Puntatore a una matrice di varianti. La dimensione della matrice corrisponde al numero di campi nell'indice.

*nTasti*<br/>
Un numero intero corrispondente alla dimensione della matrice, ovvero il numero di campi nell'indice.

> [!NOTE]
> Non specificare caratteri jolly nelle chiavi. I caratteri `Seek` jolly non restituiranno alcun record corrispondente.

### <a name="return-value"></a>Valore restituito

Diverso da zero se vengono trovati record corrispondenti, in caso contrario 0.

### <a name="remarks"></a>Osservazioni

Utilizzare la seconda versione `Seek` (matrice) di per gestire gli indici di quattro o più campi.

`Seek`consente la ricerca di indici ad alte prestazioni nei recordset di tipo tabella. È necessario impostare l'indice corrente chiamando `SetCurrentIndex` prima di chiamare `Seek`. Se l'indice identifica uno o `Seek` più campi chiave non univoci, individua il primo record che soddisfa i criteri. Se non si imposta un indice, viene generata un'eccezione.

Si noti che se non si `COleVariant` sta creando un recordset UNICODE, gli oggetti devono essere dichiarati in modo esplicito ANSI. Questa operazione può essere eseguita utilizzando la forma di costruttore [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su `VT_BSTRT` (ANSI) o utilizzando la `COleVariant` funzione [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su . `VT_BSTRT`

Quando si `Seek`chiama , si passano uno o più valori\<di chiave e un operatore di confronto ("<", " s ", "", >""" o ">"). `Seek`esegue una ricerca nei campi chiave specificati e individua il primo record che soddisfa i criteri specificati da *lpszComparison* e *pKey1*. Una volta `Seek` trovato, restituisce diverso da zero e rende corrente il record. Se `Seek` non riesce `Seek` a individuare una corrispondenza, restituisce zero e il record corrente non è definito. Quando si usa DAO direttamente, è necessario controllare in modo esplicito il NoMatch proprietà.

Se `lpszComparison` è """, ">"" o `Seek` ">", inizia all'inizio dell'indice. Se *lpszComparison* è "<" o `Seek` "<"", inizia alla fine dell'indice e esegue la ricerca all'indietro a meno che non vi siano voci di indice duplicate alla fine. In questo `Seek` caso, inizia in corrispondenza di una voce arbitraria tra le voci di indice duplicate alla fine dell'indice.

Non è necessario che sia presente `Seek`un record corrente quando si utilizza .

Per individuare un record in un recordset di tipo dynaset o snapshot che soddisfi una condizione specifica, utilizzare le operazioni Find. Per includere tutti i record, non solo quelli che soddisfano una condizione specifica, utilizzare le operazioni di spostamento per spostarsi da un record all'altro.

Non è `Seek` possibile chiamare su una tabella associata di qualsiasi tipo perché le tabelle associate devono essere aperte come recordset di tipo dynaset o snapshot. Tuttavia, se `CDaoDatabase::Open` si chiama per aprire direttamente un `Seek` database ISAM installabile, è possibile chiamare le tabelle in tale database, anche se le prestazioni potrebbero essere lente.

Per informazioni correlate, vedere l'argomento "Metodo Seek" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetabsoluteposition"></a><a name="setabsoluteposition"></a>CDaoRecordset::SetAbsolutePosition

Imposta il numero di record relativo del record corrente di un oggetto recordset.

```
void SetAbsolutePosition(long lPosition);
```

### <a name="parameters"></a>Parametri

*lPosition*<br/>
Corrisponde alla posizione ordinale del record corrente nel recordset.

### <a name="remarks"></a>Osservazioni

La `SetAbsolutePosition` chiamata consente di posizionare il puntatore del record corrente su un record specifico in base alla posizione ordinale in un recordset di tipo dynaset o snapshot. È inoltre possibile determinare il numero del record corrente chiamando [GetAbsolutePosition](#getabsoluteposition).

> [!NOTE]
> Questa funzione membro è valida solo per i recordset di tipo dynaset e snapshot.

Il AbsolutePosition valore della proprietà dell'oggetto DAO sottostante è in base zero; l'impostazione 0 si riferisce al primo record del recordset. L'impostazione di un valore maggiore del numero di record popolati fa sì che MFC generi un'eccezione. È possibile determinare il numero di record `GetRecordCount` popolati nel recordset chiamando la funzione membro.

Se il record corrente viene eliminato, il Valore della proprietà AbsolutePosition non è definito e MFC genera un'eccezione se vi viene fatto riferimento. I nuovi record vengono aggiunti alla fine della sequenza.

> [!NOTE]
> Questa proprietà non deve essere utilizzata come numero di record surrogato. I segnalibri sono ancora il modo consigliato per mantenere e tornare a una determinata posizione e sono l'unico modo per posizionare il record corrente in tutti i tipi di oggetti recordset che supportano i segnalibri. In particolare, la posizione di un determinato record cambia quando i record che lo precedono vengono eliminati. Non vi è inoltre alcuna garanzia che un determinato record avrà la stessa posizione assoluta se il recordset viene ricreato nuovamente perché l'ordine dei singoli record all'interno di un recordset non è garantito a meno che non venga creato con un'istruzione SQL utilizzando una clausola **ORDERBY.**

Per informazioni correlate, vedere l'argomento "Proprietà AbsolutePosition" nella Guida di DAO.

## <a name="cdaorecordsetsetbookmark"></a><a name="setbookmark"></a>CDaoRecordset::SetBookmark

Chiamare questa funzione membro per posizionare il recordset sul record contenente il segnalibro specificato.

```
void SetBookmark(COleVariant varBookmark);
```

### <a name="parameters"></a>Parametri

*varBookmark*<br/>
Oggetto [COleVariant](../../mfc/reference/colevariant-class.md) oggetto contenente il valore del segnalibro per un record specifico.

### <a name="remarks"></a>Osservazioni

Quando un oggetto recordset viene creato o aperto, ognuno dei relativi record dispone già di un segnalibro univoco. È possibile recuperare il segnalibro `GetBookmark` per il record `COleVariant` corrente chiamando e salvando il valore in un oggetto. È possibile tornare successivamente a `SetBookmark` tale record chiamando il valore del segnalibro salvato.

> [!NOTE]
> La chiamata a [Requery](#requery) modifica i segnalibri DAO.

Si noti che se non si `COleVariant` sta creando un recordset UNICODE, l'oggetto deve essere dichiarato in modo esplicito ANSI. Questa operazione può essere eseguita utilizzando la forma di costruttore [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su `VT_BSTRT` (ANSI) o utilizzando la `COleVariant` funzione [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su . `VT_BSTRT`

Per informazioni correlate, vedere gli argomenti "Proprietà Bookmark" e Bookmarkable Property" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetcachesize"></a><a name="setcachesize"></a>CDaoRecordset::SetCacheSize

Chiamare questa funzione membro per impostare il numero di record da memorizzati nella cache.

```
void SetCacheSize(long lSize);
```

### <a name="parameters"></a>Parametri

*lDimensione*<br/>
Specifica il numero di record. Un valore tipico è 100.A typical value is 100. L'impostazione 0 disattiva la memorizzazione nella cache. L'impostazione deve essere compresa tra 5 e 1200 record. La cache può utilizzare una notevole quantità di memoria.

### <a name="remarks"></a>Osservazioni

Una cache è uno spazio nella memoria locale che contiene i dati recuperati più di recente dal server nel caso in cui i dati verranno richiesti nuovamente durante l'esecuzione dell'applicazione. La memorizzazione dei dati nella cache migliora le prestazioni di un'applicazione che recupera i dati da un server remoto tramite oggetti recordset di tipo dynaset. Quando vengono richiesti i dati, il modulo di gestione di database Microsoft Jet controlla prima la cache per i dati richiesti anziché recuperarla dal server, operazione che richiede più tempo. I dati che non provengono da un'origine dati ODBC non vengono salvati nella cache.

Qualsiasi origine dati ODBC, ad esempio una tabella collegata, può avere una cache locale. Per creare la cache, aprire un oggetto recordset `SetCacheSize` dall'origine dati remota, chiamare le funzioni membro e e `SetCacheStart` quindi chiamare la `FillCache` funzione membro o scorrere i record utilizzando una delle operazioni di spostamento. Il *lSize* parametro della `SetCacheSize` funzione membro può essere basato sul numero di record che l'applicazione può utilizzare con una sola volta. Ad esempio, se si utilizza un recordset come origine dei dati da visualizzare `SetCacheSize` sullo schermo, è possibile passare il parametro *lSize* come 20 per visualizzare 20 record contemporaneamente.

Per informazioni correlate, vedere l'argomento "CacheSize, CacheStart Properties" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetcachestart"></a><a name="setcachestart"></a>CDaoRecordset::SetCacheStart

Chiamare questa funzione membro per specificare il segnalibro del primo record nel recordset da memorizzare nella cache.

```
void SetCacheStart(COleVariant varBookmark);
```

### <a name="parameters"></a>Parametri

*varBookmark*<br/>
Oggetto [COleVariant](../../mfc/reference/colevariant-class.md) che specifica il segnalibro del primo record del recordset da memorizzare nella cache.

### <a name="remarks"></a>Osservazioni

È possibile utilizzare il valore del segnalibro di `SetCacheStart` qualsiasi record per il parametro *varBookmark* della funzione membro. Rendere il record che si desidera avviare la cache con il record corrente, stabilire un segnalibro `SetCacheStart` per tale record utilizzando [SetBookmark](#setbookmark)e passare il valore del segnalibro come parametro per la funzione membro.

Il modulo di gestione di database Microsoft Jet richiede i record all'interno dell'intervallo della cache dalla cache e richiede i record al di fuori dell'intervallo di cache dal server.

I record recuperati dalla cache non riflettono le modifiche apportate contemporaneamente ai dati di origine da altri utenti.

Per forzare un aggiornamento di tutti i dati `SetCacheSize` memorizzati `SetCacheSize` nella cache, passare il parametro *lSize* `FillCache` di 0, chiamare nuovamente con la dimensione della cache richiesta in origine e quindi chiamare la funzione membro.

Si noti che se non si `COleVariant` sta creando un recordset UNICODE, l'oggetto deve essere dichiarato in modo esplicito ANSI. Questa operazione può essere eseguita utilizzando la forma di costruttore [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su `VT_BSTRT` (ANSI) o utilizzando la `COleVariant` funzione [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su . `VT_BSTRT`

Per informazioni correlate, vedere l'argomento CacheSize, CacheStart Properties" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetcurrentindex"></a><a name="setcurrentindex"></a>CDaoRecordset::SetCurrentIndex

Chiamare questa funzione membro per impostare un indice in un recordset di tipo tabella.

```
void SetCurrentIndex(LPCTSTR lpszIndex);
```

### <a name="parameters"></a>Parametri

*Indice di lpsz*<br/>
Puntatore contenente il nome dell'indice da impostare.

### <a name="remarks"></a>Osservazioni

I record nelle tabelle di base non vengono archiviati in un ordine particolare. L'impostazione di un indice modifica l'ordine dei record restituiti dal database, ma non influisce sull'ordine di archiviazione dei record. L'indice specificato deve essere già definito. Se si tenta di utilizzare un oggetto indice che non esiste o se l'indice non è impostato quando si chiama [Seek](#seek), MFC genera un'eccezione.

È possibile creare un nuovo indice per la tabella chiamando [CDaoTableDef::CreateIndex](../../mfc/reference/cdaotabledef-class.md#createindex) e aggiungendo il nuovo indice all'insieme Indexes del tabledef sottostante chiamando [CDaoTableDef::Append](../../mfc/reference/cdaotabledef-class.md#append)e quindi riaprendo il recordset.

I record restituiti da un recordset di tipo tabella possono essere ordinati solo in base ai indici definiti per il tabledef sottostante. Per ordinare i record in un altro ordine, è possibile aprire un recordset di tipo dynaset o snapshot utilizzando una clausola SQL **ORDERBY** archiviata in [CDaoRecordset::m_strSort](#m_strsort).

Per informazioni correlate, vedere l'argomento "Oggetto Index" e la definizione "indice corrente" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetfielddirty"></a><a name="setfielddirty"></a>CDaoRecordset::SetFieldDirty

Chiamare questa funzione membro per contrassegnare un membro dati di campo del recordset come modificato o invariato.

```
void SetFieldDirty(
    void* pv,
    BOOL bDirty = TRUE);
```

### <a name="parameters"></a>Parametri

*Pv*<br/>
Contiene l'indirizzo di un membro dati di campo nel recordset o NULL. Se NULL, tutti i membri dati di campo nel recordset vengono contrassegnati. (NULL c'è non è lo stesso di Null nella terminologia del database, che significa "non avere alcun valore.")

*bSporco*<br/>
TRUESe il membro dati di campo deve essere contrassegnato come "dirty" (modificato). In caso contrario, FALSE se il membro dati di campo deve essere contrassegnato come "pulito" (invariato).

### <a name="remarks"></a>Osservazioni

Contrassegnare i campi come invariati assicura che il campo non venga aggiornato.

Il framework contrassegna i membri dati di campo modificati per garantire che verranno scritti nel record nell'origine dati dal meccanismo DFX (Record Field Exchange) DAO. La modifica del valore di un campo in genere imposta il `SetFieldDirty` campo dirty automaticamente, pertanto raramente sarà necessario chiamare se stessi, ma a volte potrebbe essere necessario assicurarsi che le colonne vengano aggiornate o inserite in modo esplicito indipendentemente dal valore presente nel membro dati del campo. Il meccanismo DFX utilizza anche l'utilizzo di PSEUDONULL. Per ulteriori informazioni, vedere [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

Se il meccanismo del doppio buffer non viene utilizzato, la modifica del valore del campo non imposta automaticamente il campo come dirty. In questo caso, sarà necessario impostare in modo esplicito il campo come dirty. Il flag contenuto in [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controlla questo controllo automatico dei campi.

> [!NOTE]
> Chiamare questa funzione membro solo dopo aver chiamato [Edit](#edit) o [AddNew](#addnew).

L'utilizzo di NULL per il primo argomento `outputColumn` della funzione applicherà la funzione a tutti i campi, non ai campi **param** in `CDaoFieldExchange`. Ad esempio, la chiamata

[!code-cpp[NVC_MFCDatabase#6](../../mfc/codesnippet/cpp/cdaorecordset-class_6.cpp)]

imposterà `outputColumn` solo i campi su NULL; **i** campi param non saranno interessati.

Per lavorare su un **parametro,** è necessario fornire l'indirizzo effettivo della singola **parametra** su cui si desidera lavorare, ad esempio:

[!code-cpp[NVC_MFCDatabase#7](../../mfc/codesnippet/cpp/cdaorecordset-class_7.cpp)]

Ciò significa che **param** non è possibile impostare `outputColumn` tutti i campi param su NULL, come è possibile con i campi.

`SetFieldDirty`viene implementato `DoFieldExchange`tramite .

## <a name="cdaorecordsetsetfieldnull"></a><a name="setfieldnull"></a>CDaoRecordset::SetFieldNull

Chiamare questa funzione membro per contrassegnare un membro dati di campo del recordset come Null (in particolare non ha alcun valore) o come non Null.

```
void SetFieldNull(
    void* pv,
    BOOL bNull = TRUE);
```

### <a name="parameters"></a>Parametri

*Pv*<br/>
Contiene l'indirizzo di un membro dati di campo nel recordset o NULL. Se NULL, tutti i membri dati di campo nel recordset vengono contrassegnati. (NULL c'è non è lo stesso di Null nella terminologia del database, che significa "non avere alcun valore.")

*bNull*<br/>
Diverso da zero se il membro dati di campo deve essere contrassegnato come non avendo alcun valore (Null). In caso contrario, 0 se il membro dati di campo deve essere contrassegnato come non Null.

### <a name="remarks"></a>Osservazioni

`SetFieldNull`viene utilizzato per i `DoFieldExchange` campi associati nel meccanismo.

Quando si aggiunge un nuovo record a un recordset, tutti i membri dati di campo vengono inizialmente impostati su un valore Null e contrassegnati come "dirty" (modificato). Quando si recupera un record da un'origine dati, le relative colonne hanno già valori o sono Null.When you retrieve a record from a data source, its columns either have already have values or are Null. Se non è appropriato rendere null un campo, viene [generata un'eccezione CDaoException.If](../../mfc/reference/cdaoexception-class.md) it is not appropriate to make a field Null, a CDaoException is thrown.

Se si utilizza il meccanismo del doppio buffer, ad esempio, se si desidera designare in `SetFieldNull` modo specifico un campo del record corrente come che non dispone di un valore, chiamare con *bNull* impostato su TRUE per contrassegnarlo come Null. Se un campo è stato precedentemente contrassegnato come Null e ora si desidera assegnargli un valore, è sufficiente impostarne il nuovo valore. Non è necessario rimuovere il `SetFieldNull`flag Null con . Per determinare se il campo può essere Null, chiamare [IsFieldNullable](#isfieldnullable).

Se non si utilizza il meccanismo del doppio buffer, la modifica del valore del campo non imposta automaticamente il campo come dirty e non Null. È necessario impostare in modo specifico i campi dirty e non Null. Il flag contenuto in [m_bCheckCacheForDirtyFields](#m_bcheckcachefordirtyfields) controlla questo controllo automatico dei campi.

Il meccanismo DFX utilizza PSEUDONULL. Per ulteriori informazioni, vedere [CDaoFieldExchange::m_nOperation](../../mfc/reference/cdaofieldexchange-class.md#m_noperation).

> [!NOTE]
> Chiamare questa funzione membro solo dopo aver chiamato [Edit](#edit) o [AddNew](#addnew).

L'utilizzo di NULL per il primo argomento `outputColumn` della funzione applicherà la funzione solo ai campi, non ai campi **param** in `CDaoFieldExchange`. Ad esempio, la chiamata

[!code-cpp[NVC_MFCDatabase#8](../../mfc/codesnippet/cpp/cdaorecordset-class_8.cpp)]

imposterà `outputColumn` solo i campi su NULL; **i** campi param non saranno interessati.

## <a name="cdaorecordsetsetfieldvalue"></a><a name="setfieldvalue"></a>CDaoRecordset::SetFieldValue

Chiamare questa funzione membro per impostare il valore di un campo, tramite la posizione ordinale o modificando il valore della stringa.

```
virtual void SetFieldValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);

virtual void SetFieldValue(
    int nIndex,
    const COleVariant& varValue);

void SetFieldValue(
    LPCTSTR lpszName,
    LPCTSTR lpszValue);

void SetFieldValue(
    int nIndex,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>Parametri

*lpszName*<br/>
Puntatore a una stringa contenente il nome di un campo.

*varValue (valore varValue)*<br/>
Riferimento a un [oggetto COleVariant](../../mfc/reference/colevariant-class.md) contenente il valore del contenuto del campo.

*nIndex*<br/>
Intero che rappresenta la posizione ordinale del campo nell'insieme Fields del recordset (in base zero).

*lpszValore*<br/>
Puntatore a una stringa contenente il valore del contenuto del campo.

### <a name="remarks"></a>Osservazioni

Utilizzare `SetFieldValue` e [GetFieldValue](#getfieldvalue) per associare dinamicamente i campi in fase di esecuzione anziché associare in modo statico le colonne utilizzando il meccanismo [DoFieldExchange.](#dofieldexchange)

Si noti che se non si sta creando un `SetFieldValue` recordset UNICODE, `COleVariant` è necessario `COleVariant` utilizzare una forma di che non contiene un parametro oppure l'oggetto deve essere dichiarato in modo esplicito ANSI. Questa operazione può essere eseguita utilizzando la forma di costruttore [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su `VT_BSTRT` (ANSI) o utilizzando la `COleVariant` funzione [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su . `VT_BSTRT`

Per informazioni correlate, vedere gli argomenti "Oggetto campo" e "Proprietà valore" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetfieldvaluenull"></a><a name="setfieldvaluenull"></a>CDaoRecordset::SetFieldValueNull

Chiamare questa funzione membro per impostare il campo su un valore Null.Call this member function to set the field to a Null value.

```
void SetFieldValueNull(int nIndex);
void SetFieldValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Parametri

*nIndex*<br/>
Indice del campo nel recordset, per la ricerca in base all'indice in base allo zero.

*lpszName*<br/>
Nome del campo nel recordset, per la ricerca in base al nome.

### <a name="remarks"></a>Osservazioni

NULL c'è non è lo stesso di Null, che, nella terminologia del database, significa "non avere alcun valore".

Per informazioni correlate, vedere gli argomenti "Oggetto campo" e "Proprietà valore" nella Guida in linea di DAO.

## <a name="cdaorecordsetsetlockingmode"></a><a name="setlockingmode"></a>CDaoRecordset::SetLockingMode

Chiamare questa funzione membro per impostare il tipo di blocco per il recordset.

```
void SetLockingMode(BOOL bPessimistic);
```

### <a name="parameters"></a>Parametri

*bPessimistico*<br/>
Flag che indica il tipo di blocco.

### <a name="remarks"></a>Osservazioni

Quando è attivo il blocco pessimistico, la pagina 2K contenente il `Edit` record che si sta modificando viene bloccata non appena si chiama la funzione membro. La pagina viene sbloccata `Update` `Close` quando si chiama la funzione membro o o una delle operazioni Move o Find.

Quando è attivo il blocco ottimistico, la pagina 2K contenente il `Update` record viene bloccata solo durante l'aggiornamento del record con la funzione membro.

Se una pagina è bloccata, nessun altro utente può modificare i record nella stessa pagina. Se si `SetLockingMode` chiama e si passa un valore diverso da zero e un `Edit`altro utente ha già la pagina bloccata, viene generata un'eccezione quando si chiama . Gli altri utenti possono leggere i dati dalle pagine bloccate.

Se si `SetLockingMode` chiama con un `Update` valore zero e successivamente chiamare mentre la pagina è bloccata da un altro utente, si verifica un'eccezione. Per visualizzare le modifiche apportate al record da un `SetBookmark` altro utente (e perdere le modifiche), chiamare la funzione membro con il valore del segnalibro del record corrente.

Quando si utilizzano origini dati ODBC, la modalità di blocco è sempre ottimistica.

## <a name="cdaorecordsetsetparamvalue"></a><a name="setparamvalue"></a>CDaoRecordset::SetParamValue

Chiamare questa funzione membro per impostare il valore di un parametro nel recordset in fase di esecuzione.

```
virtual void SetParamValue(
    int nIndex,
    const COleVariant& varValue);

virtual void SetParamValue(
    LPCTSTR lpszName,
    const COleVariant& varValue);
```

### <a name="parameters"></a>Parametri

*nIndex*<br/>
Posizione numerica del parametro nell'insieme Parameters di querydef.

*Var*<br/>
Il valore da impostare; vedere Osservazioni.

*lpszName*<br/>
Nome del parametro di cui si desidera impostare il valore.

### <a name="remarks"></a>Osservazioni

Il parametro deve essere già stato stabilito come parte della stringa SQL del recordset. È possibile accedere al parametro in base al nome o alla posizione di indice nella raccolta.

Specificare il valore `COleVariant` da impostare come oggetto. Per informazioni sull'impostazione del `COleVariant` valore e del tipo desiderati nell'oggetto , vedere la classe [COleVariant](../../mfc/reference/colevariant-class.md). Si noti che se non si `COleVariant` sta creando un recordset UNICODE, l'oggetto deve essere dichiarato in modo esplicito ANSI. Questa operazione può essere eseguita utilizzando la forma di costruttore [COleVariant::COleVariant](../../mfc/reference/colevariant-class.md#colevariant)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su `VT_BSTRT` (ANSI) o utilizzando la `COleVariant` funzione [SetString](../../mfc/reference/colevariant-class.md#setstring)**(** *lpszSrc* **,** *vtSrc* **)** con *vtSrc* impostato su . `VT_BSTRT`

## <a name="cdaorecordsetsetparamvaluenull"></a><a name="setparamvaluenull"></a>CDaoRecordset::SetParamValueNull

Chiamare questa funzione membro per impostare il parametro su un valore Null.Call this member function to set the parameter to a Null value.

```
void SetParamValueNull(int nIndex);
void SetParamValueNull(LPCTSTR lpszName);
```

### <a name="parameters"></a>Parametri

*nIndex*<br/>
Indice del campo nel recordset, per la ricerca in base all'indice in base allo zero.

*lpszName*<br/>
Nome del campo nel recordset, per la ricerca in base al nome.

### <a name="remarks"></a>Osservazioni

NULL c'è non è lo stesso di Null, che, nella terminologia del database, significa "non avere alcun valore".

## <a name="cdaorecordsetsetpercentposition"></a><a name="setpercentposition"></a>CDaoRecordset::SetPercentPosition

Chiamare questa funzione membro per impostare un valore che modifica la posizione approssimativa del record corrente nell'oggetto recordset in base a una percentuale dei record nel recordset.

```
void SetPercentPosition(float fPosition);
```

### <a name="parameters"></a>Parametri

*fPosizione*<br/>
Numero compreso tra 0 e 100.

### <a name="remarks"></a>Osservazioni

Quando si utilizza un recordset di tipo dynaset o snapshot, popolare il recordset `SetPercentPosition`passando all'ultimo record prima di chiamare . Se si `SetPercentPosition` chiama prima di popolare completamente il recordset, la quantità di spostamento è relativa al numero di record a cui si accede come indicato dal valore di [GetRecordCount](#getrecordcount). È possibile passare all'ultimo `MoveLast`record chiamando .

Una volta `SetPercentPosition`chiamato , il record nella posizione approssimativa corrispondente a tale valore diventa corrente.

> [!NOTE]
> Non `SetPercentPosition` è consigliabile chiamare per spostare il record corrente in un record specifico in un recordset. Chiamare invece la funzione membro [SetBookmark.](#setbookmark)

Per informazioni correlate, vedere l'argomento "Proprietà PercentPosition" nella Guida di DAO.

## <a name="cdaorecordsetupdate"></a><a name="update"></a>CDaoRecordset::Aggiornamento

Chiamare questa funzione membro dopo `AddNew` `Edit` una chiamata alla funzione membro o .

```
virtual void Update();
```

### <a name="remarks"></a>Osservazioni

Questa chiamata è necessaria `AddNew` `Edit` per completare l'operazione o .

Entrambi `AddNew` `Edit` e preparare un buffer di modifica in cui vengono inseriti i dati aggiunti o modificati per il salvataggio nell'origine dati. `Update`salva i dati. Vengono aggiornati solo i campi contrassegnati o rilevati come modificati.

Se l'origine dati supporta le transazioni, è `AddNew` possibile `Edit` effettuare la chiamata (e la `Update` corrispondente o chiamata) parte di una transazione.

> [!CAUTION]
> Se si `Update` chiama senza `AddNew` `Edit`prima `Update` chiamare `CDaoException`o , viene generata un'eccezione . Se si `AddNew` `Edit`chiama o `Update` , è necessario chiamare prima di chiamare [MoveNext](#movenext) o chiudere il recordset o la connessione all'origine dati. In caso contrario, le modifiche andranno perse senza notifica.

Quando l'oggetto recordset è bloccato in modo pessimistico in `Edit` un ambiente multiutente, il record rimane bloccato dal momento in cui viene utilizzato fino al completamento dell'aggiornamento. Se il recordset è bloccato in modo ottimistico, il record viene bloccato e confrontato con il record pre-modificato prima dell'aggiornamento nel database. Se il record è `Edit`stato `Update` modificato da quando è stato chiamato , l'operazione ha esito negativo e MFC genera un'eccezione. È possibile modificare la `SetLockingMode`modalità di blocco con .

> [!NOTE]
> Il blocco ottimistico viene sempre utilizzato in formati di database esterni, ad esempio ODBC e ISAM installabile.

Per informazioni correlate, vedere gli argomenti "Metodo AddNew", "Metodo CancelUpdate", "Metodo Delete", "Proprietà LastModified", "Metodo Update" e "Proprietà EditMode" nella Guida di DAO.

## <a name="see-also"></a>Vedere anche

[Classe CObject](../../mfc/reference/cobject-class.md)<br/>
[Grafico delle gerarchie](../../mfc/hierarchy-chart.md)<br/>
[Classe CDaoTableDef](../../mfc/reference/cdaotabledef-class.md)<br/>
[CDaoWorkspace (classe)](../../mfc/reference/cdaoworkspace-class.md)<br/>
[Classe CDaoDatabase](../../mfc/reference/cdaodatabase-class.md)<br/>
[Classe CDaoQueryDef](../../mfc/reference/cdaoquerydef-class.md)<br/>
